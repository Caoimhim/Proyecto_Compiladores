Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID store_program SEMI prog1 prog2 prog3 main
Rule 2     store_program -> <empty>
Rule 3     prog1 -> class
Rule 4     prog1 -> empty
Rule 5     prog2 -> vars
Rule 6     prog2 -> empty
Rule 7     prog3 -> function
Rule 8     prog3 -> empty
Rule 9     class -> class class
Rule 10    class -> CLASS ID class1 LB class2 class3 RB SEMI
Rule 11    class1 -> INHERITS ID
Rule 12    class1 -> empty
Rule 13    class2 -> attrs
Rule 14    class2 -> empty
Rule 15    class3 -> mthds
Rule 16    class3 -> empty
Rule 17    attrs -> ATTRIBUTES attrs1
Rule 18    attrs1 -> lista_ids COLON tipo SEMI attrs2
Rule 19    attrs2 -> attrs1
Rule 20    attrs2 -> empty
Rule 21    mthds -> METHODS function
Rule 22    vars -> VARIABLES attrs1
Rule 23    tipo -> tipo_param
Rule 24    tipo -> ID
Rule 25    lista_ids -> ID list1 list2
Rule 26    list1 -> LS CTEI RS
Rule 27    list1 -> LS CTEI COMMA CTEI RS
Rule 28    list1 -> empty
Rule 29    list2 -> COMMA lista_ids
Rule 30    list2 -> empty
Rule 31    main -> MAIN LP RP LB main1 RB
Rule 32    main1 -> statement
Rule 33    main1 -> empty
Rule 34    function -> function function
Rule 35    function -> tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 main1 RB
Rule 36    store_function -> <empty>
Rule 37    func1 -> params
Rule 38    func1 -> empty
Rule 39    func2 -> vars
Rule 40    func2 -> empty
Rule 41    tipo_param -> INT
Rule 42    tipo_param -> FLOAT
Rule 43    tipo_param -> CHAR
Rule 44    params -> ID COLON tipo_param par1
Rule 45    par1 -> COMMA params
Rule 46    par1 -> empty
Rule 47    tipo_retorno -> tipo_param
Rule 48    tipo_retorno -> VOID
Rule 49    statement -> statement statement
Rule 50    statement -> assignment SEMI
Rule 51    statement -> void_call SEMI
Rule 52    statement -> read SEMI
Rule 53    statement -> write SEMI
Rule 54    statement -> if_st
Rule 55    statement -> while_st
Rule 56    statement -> from_st
Rule 57    statement -> return_st SEMI
Rule 58    assignment -> var EQ expression
Rule 59    var -> ID list1
Rule 60    var -> ID DOT ID
Rule 61    void_call -> ID call1 LP call2 RP
Rule 62    void_call -> ID call1 LP RP
Rule 63    call1 -> DOT ID
Rule 64    call1 -> empty
Rule 65    call2 -> expression
Rule 66    call2 -> call2 COMMA call2
Rule 67    read -> READ LP var read1 RP
Rule 68    read1 -> COMMA var
Rule 69    read1 -> empty
Rule 70    write -> WRITE LP write1 RP
Rule 71    write1 -> expression write2
Rule 72    write1 -> CTES write2
Rule 73    write2 -> COMMA write1
Rule 74    write2 -> empty
Rule 75    if_st -> IF LP expression RP THEN LB statement RB if1
Rule 76    if1 -> ELSE LB main1 RB
Rule 77    if1 -> empty
Rule 78    while_st -> WHILE LP expression RP DO LB main1 RB
Rule 79    from_st -> FROM ID list1 EQ expression UNTIL expression DO LB main1 RB
Rule 80    return_st -> RETURN LP expression RP
Rule 81    expression -> exp
Rule 82    expression -> exp OR exp
Rule 83    exp -> k_exp
Rule 84    exp -> k_exp AND k_exp
Rule 85    k_exp -> m_exp
Rule 86    k_exp -> m_exp LT m_exp
Rule 87    k_exp -> m_exp GT m_exp
Rule 88    k_exp -> m_exp COMP m_exp
Rule 89    k_exp -> m_exp NE m_exp
Rule 90    k_exp -> m_exp LTE m_exp
Rule 91    k_exp -> m_exp GTE m_exp
Rule 92    m_exp -> term
Rule 93    m_exp -> term PLUS term
Rule 94    m_exp -> term MIN term
Rule 95    term -> fact
Rule 96    term -> fact MUL fact
Rule 97    term -> fact DIV fact
Rule 98    fact -> LP expression RP
Rule 99    fact -> void_call
Rule 100   fact -> var_cte
Rule 101   fact -> var
Rule 102   var_cte -> CTEI
Rule 103   var_cte -> CTEF
Rule 104   var_cte -> CTEC
Rule 105   empty -> <empty>

Terminals, with rules where they appear

AND                  : 84
ATTRIBUTES           : 17
CHAR                 : 43
CLASS                : 10
COLON                : 18 44
COMMA                : 27 29 45 66 68 73
COMP                 : 88
CTEC                 : 104
CTEF                 : 103
CTEI                 : 26 27 27 102
CTES                 : 72
DIV                  : 97
DO                   : 78 79
DOT                  : 60 63
ELSE                 : 76
EQ                   : 58 79
FLOAT                : 42
FROM                 : 79
FUNCTION             : 35
GT                   : 87
GTE                  : 91
ID                   : 1 10 11 24 25 35 44 59 60 60 61 62 63 79
IF                   : 75
INHERITS             : 11
INT                  : 41
LB                   : 10 31 35 75 76 78 79
LP                   : 31 35 61 62 67 70 75 78 80 98
LS                   : 26 27
LT                   : 86
LTE                  : 90
MAIN                 : 31
METHODS              : 21
MIN                  : 94
MUL                  : 96
NE                   : 89
OR                   : 82
PLUS                 : 93
PROGRAM              : 1
RB                   : 10 31 35 75 76 78 79
READ                 : 67
RETURN               : 80
RP                   : 31 35 61 62 67 70 75 78 80 98
RS                   : 26 27
SEMI                 : 1 10 18 50 51 52 53 57
THEN                 : 75
UNTIL                : 79
VARIABLES            : 22
VOID                 : 48
WHILE                : 78
WRITE                : 70
error                : 

Nonterminals, with rules where they appear

assignment           : 50
attrs                : 13
attrs1               : 17 19 22
attrs2               : 18
call1                : 61 62
call2                : 61 66 66
class                : 3 9 9
class1               : 10
class2               : 10
class3               : 10
empty                : 4 6 8 12 14 16 20 28 30 33 38 40 46 64 69 74 77
exp                  : 81 82 82
expression           : 58 65 71 75 78 79 79 80 98
fact                 : 95 96 96 97 97
from_st              : 56
func1                : 35
func2                : 35
function             : 7 21 34 34
if1                  : 75
if_st                : 54
k_exp                : 83 84 84
list1                : 25 59 79
list2                : 25
lista_ids            : 18 29
m_exp                : 85 86 86 87 87 88 88 89 89 90 90 91 91
main                 : 1
main1                : 31 35 76 78 79
mthds                : 15
par1                 : 44
params               : 37 45
prog1                : 1
prog2                : 1
prog3                : 1
program              : 0
read                 : 52
read1                : 67
return_st            : 57
statement            : 32 49 49 75
store_function       : 35
store_program        : 1
term                 : 92 93 93 94 94
tipo                 : 18
tipo_param           : 23 44 47
tipo_retorno         : 35
var                  : 58 67 68 101
var_cte              : 100
vars                 : 5 39
void_call            : 51 99
while_st             : 55
write                : 53
write1               : 70 73
write2               : 71 72

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID store_program SEMI prog1 prog2 prog3 main

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID store_program SEMI prog1 prog2 prog3 main

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . store_program SEMI prog1 prog2 prog3 main
    (2) store_program -> .

    SEMI            reduce using rule 2 (store_program -> .)

    store_program                  shift and go to state 4

state 4

    (1) program -> PROGRAM ID store_program . SEMI prog1 prog2 prog3 main

    SEMI            shift and go to state 5


state 5

    (1) program -> PROGRAM ID store_program SEMI . prog1 prog2 prog3 main
    (3) prog1 -> . class
    (4) prog1 -> . empty
    (9) class -> . class class
    (10) class -> . CLASS ID class1 LB class2 class3 RB SEMI
    (105) empty -> .

    CLASS           shift and go to state 9
    VARIABLES       reduce using rule 105 (empty -> .)
    VOID            reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    CHAR            reduce using rule 105 (empty -> .)
    MAIN            reduce using rule 105 (empty -> .)

    prog1                          shift and go to state 6
    class                          shift and go to state 7
    empty                          shift and go to state 8

state 6

    (1) program -> PROGRAM ID store_program SEMI prog1 . prog2 prog3 main
    (5) prog2 -> . vars
    (6) prog2 -> . empty
    (22) vars -> . VARIABLES attrs1
    (105) empty -> .

    VARIABLES       shift and go to state 13
    VOID            reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    CHAR            reduce using rule 105 (empty -> .)
    MAIN            reduce using rule 105 (empty -> .)

    prog2                          shift and go to state 10
    vars                           shift and go to state 11
    empty                          shift and go to state 12

state 7

    (3) prog1 -> class .
    (9) class -> class . class
    (9) class -> . class class
    (10) class -> . CLASS ID class1 LB class2 class3 RB SEMI

    VARIABLES       reduce using rule 3 (prog1 -> class .)
    VOID            reduce using rule 3 (prog1 -> class .)
    INT             reduce using rule 3 (prog1 -> class .)
    FLOAT           reduce using rule 3 (prog1 -> class .)
    CHAR            reduce using rule 3 (prog1 -> class .)
    MAIN            reduce using rule 3 (prog1 -> class .)
    CLASS           shift and go to state 9

    class                          shift and go to state 14

state 8

    (4) prog1 -> empty .

    VARIABLES       reduce using rule 4 (prog1 -> empty .)
    VOID            reduce using rule 4 (prog1 -> empty .)
    INT             reduce using rule 4 (prog1 -> empty .)
    FLOAT           reduce using rule 4 (prog1 -> empty .)
    CHAR            reduce using rule 4 (prog1 -> empty .)
    MAIN            reduce using rule 4 (prog1 -> empty .)


state 9

    (10) class -> CLASS . ID class1 LB class2 class3 RB SEMI

    ID              shift and go to state 15


state 10

    (1) program -> PROGRAM ID store_program SEMI prog1 prog2 . prog3 main
    (7) prog3 -> . function
    (8) prog3 -> . empty
    (34) function -> . function function
    (35) function -> . tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 main1 RB
    (105) empty -> .
    (47) tipo_retorno -> . tipo_param
    (48) tipo_retorno -> . VOID
    (41) tipo_param -> . INT
    (42) tipo_param -> . FLOAT
    (43) tipo_param -> . CHAR

    MAIN            reduce using rule 105 (empty -> .)
    VOID            shift and go to state 21
    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    CHAR            shift and go to state 24

    prog3                          shift and go to state 16
    function                       shift and go to state 17
    empty                          shift and go to state 18
    tipo_retorno                   shift and go to state 19
    tipo_param                     shift and go to state 20

state 11

    (5) prog2 -> vars .

    VOID            reduce using rule 5 (prog2 -> vars .)
    INT             reduce using rule 5 (prog2 -> vars .)
    FLOAT           reduce using rule 5 (prog2 -> vars .)
    CHAR            reduce using rule 5 (prog2 -> vars .)
    MAIN            reduce using rule 5 (prog2 -> vars .)


state 12

    (6) prog2 -> empty .

    VOID            reduce using rule 6 (prog2 -> empty .)
    INT             reduce using rule 6 (prog2 -> empty .)
    FLOAT           reduce using rule 6 (prog2 -> empty .)
    CHAR            reduce using rule 6 (prog2 -> empty .)
    MAIN            reduce using rule 6 (prog2 -> empty .)


state 13

    (22) vars -> VARIABLES . attrs1
    (18) attrs1 -> . lista_ids COLON tipo SEMI attrs2
    (25) lista_ids -> . ID list1 list2

    ID              shift and go to state 27

    attrs1                         shift and go to state 25
    lista_ids                      shift and go to state 26

state 14

    (9) class -> class class .
    (9) class -> class . class
    (9) class -> . class class
    (10) class -> . CLASS ID class1 LB class2 class3 RB SEMI

  ! shift/reduce conflict for CLASS resolved as shift
    VARIABLES       reduce using rule 9 (class -> class class .)
    VOID            reduce using rule 9 (class -> class class .)
    INT             reduce using rule 9 (class -> class class .)
    FLOAT           reduce using rule 9 (class -> class class .)
    CHAR            reduce using rule 9 (class -> class class .)
    MAIN            reduce using rule 9 (class -> class class .)
    CLASS           shift and go to state 9

  ! CLASS           [ reduce using rule 9 (class -> class class .) ]

    class                          shift and go to state 14

state 15

    (10) class -> CLASS ID . class1 LB class2 class3 RB SEMI
    (11) class1 -> . INHERITS ID
    (12) class1 -> . empty
    (105) empty -> .

    INHERITS        shift and go to state 29
    LB              reduce using rule 105 (empty -> .)

    class1                         shift and go to state 28
    empty                          shift and go to state 30

state 16

    (1) program -> PROGRAM ID store_program SEMI prog1 prog2 prog3 . main
    (31) main -> . MAIN LP RP LB main1 RB

    MAIN            shift and go to state 32

    main                           shift and go to state 31

state 17

    (7) prog3 -> function .
    (34) function -> function . function
    (34) function -> . function function
    (35) function -> . tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 main1 RB
    (47) tipo_retorno -> . tipo_param
    (48) tipo_retorno -> . VOID
    (41) tipo_param -> . INT
    (42) tipo_param -> . FLOAT
    (43) tipo_param -> . CHAR

    MAIN            reduce using rule 7 (prog3 -> function .)
    VOID            shift and go to state 21
    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    CHAR            shift and go to state 24

    function                       shift and go to state 33
    tipo_retorno                   shift and go to state 19
    tipo_param                     shift and go to state 20

state 18

    (8) prog3 -> empty .

    MAIN            reduce using rule 8 (prog3 -> empty .)


state 19

    (35) function -> tipo_retorno . FUNCTION ID store_function LP func1 RP LB func2 main1 RB

    FUNCTION        shift and go to state 34


state 20

    (47) tipo_retorno -> tipo_param .

    FUNCTION        reduce using rule 47 (tipo_retorno -> tipo_param .)


state 21

    (48) tipo_retorno -> VOID .

    FUNCTION        reduce using rule 48 (tipo_retorno -> VOID .)


state 22

    (41) tipo_param -> INT .

    FUNCTION        reduce using rule 41 (tipo_param -> INT .)
    SEMI            reduce using rule 41 (tipo_param -> INT .)
    COMMA           reduce using rule 41 (tipo_param -> INT .)
    RP              reduce using rule 41 (tipo_param -> INT .)


state 23

    (42) tipo_param -> FLOAT .

    FUNCTION        reduce using rule 42 (tipo_param -> FLOAT .)
    SEMI            reduce using rule 42 (tipo_param -> FLOAT .)
    COMMA           reduce using rule 42 (tipo_param -> FLOAT .)
    RP              reduce using rule 42 (tipo_param -> FLOAT .)


state 24

    (43) tipo_param -> CHAR .

    FUNCTION        reduce using rule 43 (tipo_param -> CHAR .)
    SEMI            reduce using rule 43 (tipo_param -> CHAR .)
    COMMA           reduce using rule 43 (tipo_param -> CHAR .)
    RP              reduce using rule 43 (tipo_param -> CHAR .)


state 25

    (22) vars -> VARIABLES attrs1 .

    VOID            reduce using rule 22 (vars -> VARIABLES attrs1 .)
    INT             reduce using rule 22 (vars -> VARIABLES attrs1 .)
    FLOAT           reduce using rule 22 (vars -> VARIABLES attrs1 .)
    CHAR            reduce using rule 22 (vars -> VARIABLES attrs1 .)
    MAIN            reduce using rule 22 (vars -> VARIABLES attrs1 .)
    ID              reduce using rule 22 (vars -> VARIABLES attrs1 .)
    READ            reduce using rule 22 (vars -> VARIABLES attrs1 .)
    WRITE           reduce using rule 22 (vars -> VARIABLES attrs1 .)
    IF              reduce using rule 22 (vars -> VARIABLES attrs1 .)
    WHILE           reduce using rule 22 (vars -> VARIABLES attrs1 .)
    FROM            reduce using rule 22 (vars -> VARIABLES attrs1 .)
    RETURN          reduce using rule 22 (vars -> VARIABLES attrs1 .)
    RB              reduce using rule 22 (vars -> VARIABLES attrs1 .)


state 26

    (18) attrs1 -> lista_ids . COLON tipo SEMI attrs2

    COLON           shift and go to state 35


state 27

    (25) lista_ids -> ID . list1 list2
    (26) list1 -> . LS CTEI RS
    (27) list1 -> . LS CTEI COMMA CTEI RS
    (28) list1 -> . empty
    (105) empty -> .

    LS              shift and go to state 37
    COMMA           reduce using rule 105 (empty -> .)
    COLON           reduce using rule 105 (empty -> .)

    list1                          shift and go to state 36
    empty                          shift and go to state 38

state 28

    (10) class -> CLASS ID class1 . LB class2 class3 RB SEMI

    LB              shift and go to state 39


state 29

    (11) class1 -> INHERITS . ID

    ID              shift and go to state 40


state 30

    (12) class1 -> empty .

    LB              reduce using rule 12 (class1 -> empty .)


state 31

    (1) program -> PROGRAM ID store_program SEMI prog1 prog2 prog3 main .

    $end            reduce using rule 1 (program -> PROGRAM ID store_program SEMI prog1 prog2 prog3 main .)


state 32

    (31) main -> MAIN . LP RP LB main1 RB

    LP              shift and go to state 41


state 33

    (34) function -> function function .
    (34) function -> function . function
    (34) function -> . function function
    (35) function -> . tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 main1 RB
    (47) tipo_retorno -> . tipo_param
    (48) tipo_retorno -> . VOID
    (41) tipo_param -> . INT
    (42) tipo_param -> . FLOAT
    (43) tipo_param -> . CHAR

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    MAIN            reduce using rule 34 (function -> function function .)
    RB              reduce using rule 34 (function -> function function .)
    VOID            shift and go to state 21
    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    CHAR            shift and go to state 24

  ! VOID            [ reduce using rule 34 (function -> function function .) ]
  ! INT             [ reduce using rule 34 (function -> function function .) ]
  ! FLOAT           [ reduce using rule 34 (function -> function function .) ]
  ! CHAR            [ reduce using rule 34 (function -> function function .) ]

    function                       shift and go to state 33
    tipo_retorno                   shift and go to state 19
    tipo_param                     shift and go to state 20

state 34

    (35) function -> tipo_retorno FUNCTION . ID store_function LP func1 RP LB func2 main1 RB

    ID              shift and go to state 42


state 35

    (18) attrs1 -> lista_ids COLON . tipo SEMI attrs2
    (23) tipo -> . tipo_param
    (24) tipo -> . ID
    (41) tipo_param -> . INT
    (42) tipo_param -> . FLOAT
    (43) tipo_param -> . CHAR

    ID              shift and go to state 45
    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    CHAR            shift and go to state 24

    tipo                           shift and go to state 43
    tipo_param                     shift and go to state 44

state 36

    (25) lista_ids -> ID list1 . list2
    (29) list2 -> . COMMA lista_ids
    (30) list2 -> . empty
    (105) empty -> .

    COMMA           shift and go to state 47
    COLON           reduce using rule 105 (empty -> .)

    list2                          shift and go to state 46
    empty                          shift and go to state 48

state 37

    (26) list1 -> LS . CTEI RS
    (27) list1 -> LS . CTEI COMMA CTEI RS

    CTEI            shift and go to state 49


state 38

    (28) list1 -> empty .

    COMMA           reduce using rule 28 (list1 -> empty .)
    COLON           reduce using rule 28 (list1 -> empty .)
    EQ              reduce using rule 28 (list1 -> empty .)
    RP              reduce using rule 28 (list1 -> empty .)


state 39

    (10) class -> CLASS ID class1 LB . class2 class3 RB SEMI
    (13) class2 -> . attrs
    (14) class2 -> . empty
    (17) attrs -> . ATTRIBUTES attrs1
    (105) empty -> .

    ATTRIBUTES      shift and go to state 53
    METHODS         reduce using rule 105 (empty -> .)
    RB              reduce using rule 105 (empty -> .)

    class2                         shift and go to state 50
    attrs                          shift and go to state 51
    empty                          shift and go to state 52

state 40

    (11) class1 -> INHERITS ID .

    LB              reduce using rule 11 (class1 -> INHERITS ID .)


state 41

    (31) main -> MAIN LP . RP LB main1 RB

    RP              shift and go to state 54


state 42

    (35) function -> tipo_retorno FUNCTION ID . store_function LP func1 RP LB func2 main1 RB
    (36) store_function -> .

    LP              reduce using rule 36 (store_function -> .)

    store_function                 shift and go to state 55

state 43

    (18) attrs1 -> lista_ids COLON tipo . SEMI attrs2

    SEMI            shift and go to state 56


state 44

    (23) tipo -> tipo_param .

    SEMI            reduce using rule 23 (tipo -> tipo_param .)


state 45

    (24) tipo -> ID .

    SEMI            reduce using rule 24 (tipo -> ID .)


state 46

    (25) lista_ids -> ID list1 list2 .

    COLON           reduce using rule 25 (lista_ids -> ID list1 list2 .)


state 47

    (29) list2 -> COMMA . lista_ids
    (25) lista_ids -> . ID list1 list2

    ID              shift and go to state 27

    lista_ids                      shift and go to state 57

state 48

    (30) list2 -> empty .

    COLON           reduce using rule 30 (list2 -> empty .)


state 49

    (26) list1 -> LS CTEI . RS
    (27) list1 -> LS CTEI . COMMA CTEI RS

    RS              shift and go to state 58
    COMMA           shift and go to state 59


state 50

    (10) class -> CLASS ID class1 LB class2 . class3 RB SEMI
    (15) class3 -> . mthds
    (16) class3 -> . empty
    (21) mthds -> . METHODS function
    (105) empty -> .

    METHODS         shift and go to state 63
    RB              reduce using rule 105 (empty -> .)

    class3                         shift and go to state 60
    mthds                          shift and go to state 61
    empty                          shift and go to state 62

state 51

    (13) class2 -> attrs .

    METHODS         reduce using rule 13 (class2 -> attrs .)
    RB              reduce using rule 13 (class2 -> attrs .)


state 52

    (14) class2 -> empty .

    METHODS         reduce using rule 14 (class2 -> empty .)
    RB              reduce using rule 14 (class2 -> empty .)


state 53

    (17) attrs -> ATTRIBUTES . attrs1
    (18) attrs1 -> . lista_ids COLON tipo SEMI attrs2
    (25) lista_ids -> . ID list1 list2

    ID              shift and go to state 27

    attrs1                         shift and go to state 64
    lista_ids                      shift and go to state 26

state 54

    (31) main -> MAIN LP RP . LB main1 RB

    LB              shift and go to state 65


state 55

    (35) function -> tipo_retorno FUNCTION ID store_function . LP func1 RP LB func2 main1 RB

    LP              shift and go to state 66


state 56

    (18) attrs1 -> lista_ids COLON tipo SEMI . attrs2
    (19) attrs2 -> . attrs1
    (20) attrs2 -> . empty
    (18) attrs1 -> . lista_ids COLON tipo SEMI attrs2
    (105) empty -> .
    (25) lista_ids -> . ID list1 list2

  ! shift/reduce conflict for ID resolved as shift
    VOID            reduce using rule 105 (empty -> .)
    INT             reduce using rule 105 (empty -> .)
    FLOAT           reduce using rule 105 (empty -> .)
    CHAR            reduce using rule 105 (empty -> .)
    MAIN            reduce using rule 105 (empty -> .)
    READ            reduce using rule 105 (empty -> .)
    WRITE           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FROM            reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)
    RB              reduce using rule 105 (empty -> .)
    METHODS         reduce using rule 105 (empty -> .)
    ID              shift and go to state 27

  ! ID              [ reduce using rule 105 (empty -> .) ]

    lista_ids                      shift and go to state 26
    attrs2                         shift and go to state 67
    attrs1                         shift and go to state 68
    empty                          shift and go to state 69

state 57

    (29) list2 -> COMMA lista_ids .

    COLON           reduce using rule 29 (list2 -> COMMA lista_ids .)


state 58

    (26) list1 -> LS CTEI RS .

    COMMA           reduce using rule 26 (list1 -> LS CTEI RS .)
    COLON           reduce using rule 26 (list1 -> LS CTEI RS .)
    EQ              reduce using rule 26 (list1 -> LS CTEI RS .)
    MUL             reduce using rule 26 (list1 -> LS CTEI RS .)
    DIV             reduce using rule 26 (list1 -> LS CTEI RS .)
    PLUS            reduce using rule 26 (list1 -> LS CTEI RS .)
    MIN             reduce using rule 26 (list1 -> LS CTEI RS .)
    LT              reduce using rule 26 (list1 -> LS CTEI RS .)
    GT              reduce using rule 26 (list1 -> LS CTEI RS .)
    COMP            reduce using rule 26 (list1 -> LS CTEI RS .)
    NE              reduce using rule 26 (list1 -> LS CTEI RS .)
    LTE             reduce using rule 26 (list1 -> LS CTEI RS .)
    GTE             reduce using rule 26 (list1 -> LS CTEI RS .)
    AND             reduce using rule 26 (list1 -> LS CTEI RS .)
    OR              reduce using rule 26 (list1 -> LS CTEI RS .)
    SEMI            reduce using rule 26 (list1 -> LS CTEI RS .)
    RP              reduce using rule 26 (list1 -> LS CTEI RS .)
    UNTIL           reduce using rule 26 (list1 -> LS CTEI RS .)
    DO              reduce using rule 26 (list1 -> LS CTEI RS .)


state 59

    (27) list1 -> LS CTEI COMMA . CTEI RS

    CTEI            shift and go to state 70


state 60

    (10) class -> CLASS ID class1 LB class2 class3 . RB SEMI

    RB              shift and go to state 71


state 61

    (15) class3 -> mthds .

    RB              reduce using rule 15 (class3 -> mthds .)


state 62

    (16) class3 -> empty .

    RB              reduce using rule 16 (class3 -> empty .)


state 63

    (21) mthds -> METHODS . function
    (34) function -> . function function
    (35) function -> . tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 main1 RB
    (47) tipo_retorno -> . tipo_param
    (48) tipo_retorno -> . VOID
    (41) tipo_param -> . INT
    (42) tipo_param -> . FLOAT
    (43) tipo_param -> . CHAR

    VOID            shift and go to state 21
    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    CHAR            shift and go to state 24

    function                       shift and go to state 72
    tipo_retorno                   shift and go to state 19
    tipo_param                     shift and go to state 20

state 64

    (17) attrs -> ATTRIBUTES attrs1 .

    METHODS         reduce using rule 17 (attrs -> ATTRIBUTES attrs1 .)
    RB              reduce using rule 17 (attrs -> ATTRIBUTES attrs1 .)


state 65

    (31) main -> MAIN LP RP LB . main1 RB
    (32) main1 -> . statement
    (33) main1 -> . empty
    (49) statement -> . statement statement
    (50) statement -> . assignment SEMI
    (51) statement -> . void_call SEMI
    (52) statement -> . read SEMI
    (53) statement -> . write SEMI
    (54) statement -> . if_st
    (55) statement -> . while_st
    (56) statement -> . from_st
    (57) statement -> . return_st SEMI
    (105) empty -> .
    (58) assignment -> . var EQ expression
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (67) read -> . READ LP var read1 RP
    (70) write -> . WRITE LP write1 RP
    (75) if_st -> . IF LP expression RP THEN LB statement RB if1
    (78) while_st -> . WHILE LP expression RP DO LB main1 RB
    (79) from_st -> . FROM ID list1 EQ expression UNTIL expression DO LB main1 RB
    (80) return_st -> . RETURN LP expression RP
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    RB              reduce using rule 105 (empty -> .)
    ID              shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    WHILE           shift and go to state 89
    FROM            shift and go to state 90
    RETURN          shift and go to state 91

    main1                          shift and go to state 73
    statement                      shift and go to state 74
    empty                          shift and go to state 75
    assignment                     shift and go to state 76
    void_call                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    if_st                          shift and go to state 80
    while_st                       shift and go to state 81
    from_st                        shift and go to state 82
    return_st                      shift and go to state 83
    var                            shift and go to state 84

state 66

    (35) function -> tipo_retorno FUNCTION ID store_function LP . func1 RP LB func2 main1 RB
    (37) func1 -> . params
    (38) func1 -> . empty
    (44) params -> . ID COLON tipo_param par1
    (105) empty -> .

    ID              shift and go to state 92
    RP              reduce using rule 105 (empty -> .)

    func1                          shift and go to state 93
    params                         shift and go to state 94
    empty                          shift and go to state 95

state 67

    (18) attrs1 -> lista_ids COLON tipo SEMI attrs2 .

    VOID            reduce using rule 18 (attrs1 -> lista_ids COLON tipo SEMI attrs2 .)
    INT             reduce using rule 18 (attrs1 -> lista_ids COLON tipo SEMI attrs2 .)
    FLOAT           reduce using rule 18 (attrs1 -> lista_ids COLON tipo SEMI attrs2 .)
    CHAR            reduce using rule 18 (attrs1 -> lista_ids COLON tipo SEMI attrs2 .)
    MAIN            reduce using rule 18 (attrs1 -> lista_ids COLON tipo SEMI attrs2 .)
    ID              reduce using rule 18 (attrs1 -> lista_ids COLON tipo SEMI attrs2 .)
    READ            reduce using rule 18 (attrs1 -> lista_ids COLON tipo SEMI attrs2 .)
    WRITE           reduce using rule 18 (attrs1 -> lista_ids COLON tipo SEMI attrs2 .)
    IF              reduce using rule 18 (attrs1 -> lista_ids COLON tipo SEMI attrs2 .)
    WHILE           reduce using rule 18 (attrs1 -> lista_ids COLON tipo SEMI attrs2 .)
    FROM            reduce using rule 18 (attrs1 -> lista_ids COLON tipo SEMI attrs2 .)
    RETURN          reduce using rule 18 (attrs1 -> lista_ids COLON tipo SEMI attrs2 .)
    RB              reduce using rule 18 (attrs1 -> lista_ids COLON tipo SEMI attrs2 .)
    METHODS         reduce using rule 18 (attrs1 -> lista_ids COLON tipo SEMI attrs2 .)


state 68

    (19) attrs2 -> attrs1 .

    VOID            reduce using rule 19 (attrs2 -> attrs1 .)
    INT             reduce using rule 19 (attrs2 -> attrs1 .)
    FLOAT           reduce using rule 19 (attrs2 -> attrs1 .)
    CHAR            reduce using rule 19 (attrs2 -> attrs1 .)
    MAIN            reduce using rule 19 (attrs2 -> attrs1 .)
    ID              reduce using rule 19 (attrs2 -> attrs1 .)
    READ            reduce using rule 19 (attrs2 -> attrs1 .)
    WRITE           reduce using rule 19 (attrs2 -> attrs1 .)
    IF              reduce using rule 19 (attrs2 -> attrs1 .)
    WHILE           reduce using rule 19 (attrs2 -> attrs1 .)
    FROM            reduce using rule 19 (attrs2 -> attrs1 .)
    RETURN          reduce using rule 19 (attrs2 -> attrs1 .)
    RB              reduce using rule 19 (attrs2 -> attrs1 .)
    METHODS         reduce using rule 19 (attrs2 -> attrs1 .)


state 69

    (20) attrs2 -> empty .

    VOID            reduce using rule 20 (attrs2 -> empty .)
    INT             reduce using rule 20 (attrs2 -> empty .)
    FLOAT           reduce using rule 20 (attrs2 -> empty .)
    CHAR            reduce using rule 20 (attrs2 -> empty .)
    MAIN            reduce using rule 20 (attrs2 -> empty .)
    ID              reduce using rule 20 (attrs2 -> empty .)
    READ            reduce using rule 20 (attrs2 -> empty .)
    WRITE           reduce using rule 20 (attrs2 -> empty .)
    IF              reduce using rule 20 (attrs2 -> empty .)
    WHILE           reduce using rule 20 (attrs2 -> empty .)
    FROM            reduce using rule 20 (attrs2 -> empty .)
    RETURN          reduce using rule 20 (attrs2 -> empty .)
    RB              reduce using rule 20 (attrs2 -> empty .)
    METHODS         reduce using rule 20 (attrs2 -> empty .)


state 70

    (27) list1 -> LS CTEI COMMA CTEI . RS

    RS              shift and go to state 96


state 71

    (10) class -> CLASS ID class1 LB class2 class3 RB . SEMI

    SEMI            shift and go to state 97


state 72

    (21) mthds -> METHODS function .
    (34) function -> function . function
    (34) function -> . function function
    (35) function -> . tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 main1 RB
    (47) tipo_retorno -> . tipo_param
    (48) tipo_retorno -> . VOID
    (41) tipo_param -> . INT
    (42) tipo_param -> . FLOAT
    (43) tipo_param -> . CHAR

    RB              reduce using rule 21 (mthds -> METHODS function .)
    VOID            shift and go to state 21
    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    CHAR            shift and go to state 24

    function                       shift and go to state 33
    tipo_retorno                   shift and go to state 19
    tipo_param                     shift and go to state 20

state 73

    (31) main -> MAIN LP RP LB main1 . RB

    RB              shift and go to state 98


state 74

    (32) main1 -> statement .
    (49) statement -> statement . statement
    (49) statement -> . statement statement
    (50) statement -> . assignment SEMI
    (51) statement -> . void_call SEMI
    (52) statement -> . read SEMI
    (53) statement -> . write SEMI
    (54) statement -> . if_st
    (55) statement -> . while_st
    (56) statement -> . from_st
    (57) statement -> . return_st SEMI
    (58) assignment -> . var EQ expression
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (67) read -> . READ LP var read1 RP
    (70) write -> . WRITE LP write1 RP
    (75) if_st -> . IF LP expression RP THEN LB statement RB if1
    (78) while_st -> . WHILE LP expression RP DO LB main1 RB
    (79) from_st -> . FROM ID list1 EQ expression UNTIL expression DO LB main1 RB
    (80) return_st -> . RETURN LP expression RP
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    RB              reduce using rule 32 (main1 -> statement .)
    ID              shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    WHILE           shift and go to state 89
    FROM            shift and go to state 90
    RETURN          shift and go to state 91

    statement                      shift and go to state 99
    assignment                     shift and go to state 76
    void_call                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    if_st                          shift and go to state 80
    while_st                       shift and go to state 81
    from_st                        shift and go to state 82
    return_st                      shift and go to state 83
    var                            shift and go to state 84

state 75

    (33) main1 -> empty .

    RB              reduce using rule 33 (main1 -> empty .)


state 76

    (50) statement -> assignment . SEMI

    SEMI            shift and go to state 100


state 77

    (51) statement -> void_call . SEMI

    SEMI            shift and go to state 101


state 78

    (52) statement -> read . SEMI

    SEMI            shift and go to state 102


state 79

    (53) statement -> write . SEMI

    SEMI            shift and go to state 103


state 80

    (54) statement -> if_st .

    ID              reduce using rule 54 (statement -> if_st .)
    READ            reduce using rule 54 (statement -> if_st .)
    WRITE           reduce using rule 54 (statement -> if_st .)
    IF              reduce using rule 54 (statement -> if_st .)
    WHILE           reduce using rule 54 (statement -> if_st .)
    FROM            reduce using rule 54 (statement -> if_st .)
    RETURN          reduce using rule 54 (statement -> if_st .)
    RB              reduce using rule 54 (statement -> if_st .)


state 81

    (55) statement -> while_st .

    ID              reduce using rule 55 (statement -> while_st .)
    READ            reduce using rule 55 (statement -> while_st .)
    WRITE           reduce using rule 55 (statement -> while_st .)
    IF              reduce using rule 55 (statement -> while_st .)
    WHILE           reduce using rule 55 (statement -> while_st .)
    FROM            reduce using rule 55 (statement -> while_st .)
    RETURN          reduce using rule 55 (statement -> while_st .)
    RB              reduce using rule 55 (statement -> while_st .)


state 82

    (56) statement -> from_st .

    ID              reduce using rule 56 (statement -> from_st .)
    READ            reduce using rule 56 (statement -> from_st .)
    WRITE           reduce using rule 56 (statement -> from_st .)
    IF              reduce using rule 56 (statement -> from_st .)
    WHILE           reduce using rule 56 (statement -> from_st .)
    FROM            reduce using rule 56 (statement -> from_st .)
    RETURN          reduce using rule 56 (statement -> from_st .)
    RB              reduce using rule 56 (statement -> from_st .)


state 83

    (57) statement -> return_st . SEMI

    SEMI            shift and go to state 104


state 84

    (58) assignment -> var . EQ expression

    EQ              shift and go to state 105


state 85

    (61) void_call -> ID . call1 LP call2 RP
    (62) void_call -> ID . call1 LP RP
    (59) var -> ID . list1
    (60) var -> ID . DOT ID
    (63) call1 -> . DOT ID
    (64) call1 -> . empty
    (26) list1 -> . LS CTEI RS
    (27) list1 -> . LS CTEI COMMA CTEI RS
    (28) list1 -> . empty
    (105) empty -> .

    DOT             shift and go to state 108
    LS              shift and go to state 37
    LP              reduce using rule 105 (empty -> .)
    EQ              reduce using rule 105 (empty -> .)
    MUL             reduce using rule 105 (empty -> .)
    DIV             reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MIN             reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    COMP            reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    LTE             reduce using rule 105 (empty -> .)
    GTE             reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)
    RP              reduce using rule 105 (empty -> .)
    UNTIL           reduce using rule 105 (empty -> .)
    DO              reduce using rule 105 (empty -> .)

    call1                          shift and go to state 106
    list1                          shift and go to state 107
    empty                          shift and go to state 109

state 86

    (67) read -> READ . LP var read1 RP

    LP              shift and go to state 110


state 87

    (70) write -> WRITE . LP write1 RP

    LP              shift and go to state 111


state 88

    (75) if_st -> IF . LP expression RP THEN LB statement RB if1

    LP              shift and go to state 112


state 89

    (78) while_st -> WHILE . LP expression RP DO LB main1 RB

    LP              shift and go to state 113


state 90

    (79) from_st -> FROM . ID list1 EQ expression UNTIL expression DO LB main1 RB

    ID              shift and go to state 114


state 91

    (80) return_st -> RETURN . LP expression RP

    LP              shift and go to state 115


state 92

    (44) params -> ID . COLON tipo_param par1

    COLON           shift and go to state 116


state 93

    (35) function -> tipo_retorno FUNCTION ID store_function LP func1 . RP LB func2 main1 RB

    RP              shift and go to state 117


state 94

    (37) func1 -> params .

    RP              reduce using rule 37 (func1 -> params .)


state 95

    (38) func1 -> empty .

    RP              reduce using rule 38 (func1 -> empty .)


state 96

    (27) list1 -> LS CTEI COMMA CTEI RS .

    COMMA           reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    COLON           reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    EQ              reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    MUL             reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    DIV             reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    PLUS            reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    MIN             reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    LT              reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    GT              reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    COMP            reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    NE              reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    LTE             reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    GTE             reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    AND             reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    OR              reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    SEMI            reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    RP              reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    UNTIL           reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)
    DO              reduce using rule 27 (list1 -> LS CTEI COMMA CTEI RS .)


state 97

    (10) class -> CLASS ID class1 LB class2 class3 RB SEMI .

    CLASS           reduce using rule 10 (class -> CLASS ID class1 LB class2 class3 RB SEMI .)
    VARIABLES       reduce using rule 10 (class -> CLASS ID class1 LB class2 class3 RB SEMI .)
    VOID            reduce using rule 10 (class -> CLASS ID class1 LB class2 class3 RB SEMI .)
    INT             reduce using rule 10 (class -> CLASS ID class1 LB class2 class3 RB SEMI .)
    FLOAT           reduce using rule 10 (class -> CLASS ID class1 LB class2 class3 RB SEMI .)
    CHAR            reduce using rule 10 (class -> CLASS ID class1 LB class2 class3 RB SEMI .)
    MAIN            reduce using rule 10 (class -> CLASS ID class1 LB class2 class3 RB SEMI .)


state 98

    (31) main -> MAIN LP RP LB main1 RB .

    $end            reduce using rule 31 (main -> MAIN LP RP LB main1 RB .)


state 99

    (49) statement -> statement statement .
    (49) statement -> statement . statement
    (49) statement -> . statement statement
    (50) statement -> . assignment SEMI
    (51) statement -> . void_call SEMI
    (52) statement -> . read SEMI
    (53) statement -> . write SEMI
    (54) statement -> . if_st
    (55) statement -> . while_st
    (56) statement -> . from_st
    (57) statement -> . return_st SEMI
    (58) assignment -> . var EQ expression
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (67) read -> . READ LP var read1 RP
    (70) write -> . WRITE LP write1 RP
    (75) if_st -> . IF LP expression RP THEN LB statement RB if1
    (78) while_st -> . WHILE LP expression RP DO LB main1 RB
    (79) from_st -> . FROM ID list1 EQ expression UNTIL expression DO LB main1 RB
    (80) return_st -> . RETURN LP expression RP
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FROM resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
    RB              reduce using rule 49 (statement -> statement statement .)
    ID              shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    WHILE           shift and go to state 89
    FROM            shift and go to state 90
    RETURN          shift and go to state 91

  ! ID              [ reduce using rule 49 (statement -> statement statement .) ]
  ! READ            [ reduce using rule 49 (statement -> statement statement .) ]
  ! WRITE           [ reduce using rule 49 (statement -> statement statement .) ]
  ! IF              [ reduce using rule 49 (statement -> statement statement .) ]
  ! WHILE           [ reduce using rule 49 (statement -> statement statement .) ]
  ! FROM            [ reduce using rule 49 (statement -> statement statement .) ]
  ! RETURN          [ reduce using rule 49 (statement -> statement statement .) ]

    statement                      shift and go to state 99
    assignment                     shift and go to state 76
    void_call                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    if_st                          shift and go to state 80
    while_st                       shift and go to state 81
    from_st                        shift and go to state 82
    return_st                      shift and go to state 83
    var                            shift and go to state 84

state 100

    (50) statement -> assignment SEMI .

    ID              reduce using rule 50 (statement -> assignment SEMI .)
    READ            reduce using rule 50 (statement -> assignment SEMI .)
    WRITE           reduce using rule 50 (statement -> assignment SEMI .)
    IF              reduce using rule 50 (statement -> assignment SEMI .)
    WHILE           reduce using rule 50 (statement -> assignment SEMI .)
    FROM            reduce using rule 50 (statement -> assignment SEMI .)
    RETURN          reduce using rule 50 (statement -> assignment SEMI .)
    RB              reduce using rule 50 (statement -> assignment SEMI .)


state 101

    (51) statement -> void_call SEMI .

    ID              reduce using rule 51 (statement -> void_call SEMI .)
    READ            reduce using rule 51 (statement -> void_call SEMI .)
    WRITE           reduce using rule 51 (statement -> void_call SEMI .)
    IF              reduce using rule 51 (statement -> void_call SEMI .)
    WHILE           reduce using rule 51 (statement -> void_call SEMI .)
    FROM            reduce using rule 51 (statement -> void_call SEMI .)
    RETURN          reduce using rule 51 (statement -> void_call SEMI .)
    RB              reduce using rule 51 (statement -> void_call SEMI .)


state 102

    (52) statement -> read SEMI .

    ID              reduce using rule 52 (statement -> read SEMI .)
    READ            reduce using rule 52 (statement -> read SEMI .)
    WRITE           reduce using rule 52 (statement -> read SEMI .)
    IF              reduce using rule 52 (statement -> read SEMI .)
    WHILE           reduce using rule 52 (statement -> read SEMI .)
    FROM            reduce using rule 52 (statement -> read SEMI .)
    RETURN          reduce using rule 52 (statement -> read SEMI .)
    RB              reduce using rule 52 (statement -> read SEMI .)


state 103

    (53) statement -> write SEMI .

    ID              reduce using rule 53 (statement -> write SEMI .)
    READ            reduce using rule 53 (statement -> write SEMI .)
    WRITE           reduce using rule 53 (statement -> write SEMI .)
    IF              reduce using rule 53 (statement -> write SEMI .)
    WHILE           reduce using rule 53 (statement -> write SEMI .)
    FROM            reduce using rule 53 (statement -> write SEMI .)
    RETURN          reduce using rule 53 (statement -> write SEMI .)
    RB              reduce using rule 53 (statement -> write SEMI .)


state 104

    (57) statement -> return_st SEMI .

    ID              reduce using rule 57 (statement -> return_st SEMI .)
    READ            reduce using rule 57 (statement -> return_st SEMI .)
    WRITE           reduce using rule 57 (statement -> return_st SEMI .)
    IF              reduce using rule 57 (statement -> return_st SEMI .)
    WHILE           reduce using rule 57 (statement -> return_st SEMI .)
    FROM            reduce using rule 57 (statement -> return_st SEMI .)
    RETURN          reduce using rule 57 (statement -> return_st SEMI .)
    RB              reduce using rule 57 (statement -> return_st SEMI .)


state 105

    (58) assignment -> var EQ . expression
    (81) expression -> . exp
    (82) expression -> . exp OR exp
    (83) exp -> . k_exp
    (84) exp -> . k_exp AND k_exp
    (85) k_exp -> . m_exp
    (86) k_exp -> . m_exp LT m_exp
    (87) k_exp -> . m_exp GT m_exp
    (88) k_exp -> . m_exp COMP m_exp
    (89) k_exp -> . m_exp NE m_exp
    (90) k_exp -> . m_exp LTE m_exp
    (91) k_exp -> . m_exp GTE m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    var                            shift and go to state 118
    expression                     shift and go to state 119
    exp                            shift and go to state 120
    k_exp                          shift and go to state 121
    m_exp                          shift and go to state 122
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127

state 106

    (61) void_call -> ID call1 . LP call2 RP
    (62) void_call -> ID call1 . LP RP

    LP              shift and go to state 131


state 107

    (59) var -> ID list1 .

    EQ              reduce using rule 59 (var -> ID list1 .)
    MUL             reduce using rule 59 (var -> ID list1 .)
    DIV             reduce using rule 59 (var -> ID list1 .)
    PLUS            reduce using rule 59 (var -> ID list1 .)
    MIN             reduce using rule 59 (var -> ID list1 .)
    LT              reduce using rule 59 (var -> ID list1 .)
    GT              reduce using rule 59 (var -> ID list1 .)
    COMP            reduce using rule 59 (var -> ID list1 .)
    NE              reduce using rule 59 (var -> ID list1 .)
    LTE             reduce using rule 59 (var -> ID list1 .)
    GTE             reduce using rule 59 (var -> ID list1 .)
    AND             reduce using rule 59 (var -> ID list1 .)
    OR              reduce using rule 59 (var -> ID list1 .)
    SEMI            reduce using rule 59 (var -> ID list1 .)
    COMMA           reduce using rule 59 (var -> ID list1 .)
    RP              reduce using rule 59 (var -> ID list1 .)
    UNTIL           reduce using rule 59 (var -> ID list1 .)
    DO              reduce using rule 59 (var -> ID list1 .)


state 108

    (60) var -> ID DOT . ID
    (63) call1 -> DOT . ID

    ID              shift and go to state 132


state 109

    (64) call1 -> empty .
    (28) list1 -> empty .

    LP              reduce using rule 64 (call1 -> empty .)
    EQ              reduce using rule 28 (list1 -> empty .)
    MUL             reduce using rule 28 (list1 -> empty .)
    DIV             reduce using rule 28 (list1 -> empty .)
    PLUS            reduce using rule 28 (list1 -> empty .)
    MIN             reduce using rule 28 (list1 -> empty .)
    LT              reduce using rule 28 (list1 -> empty .)
    GT              reduce using rule 28 (list1 -> empty .)
    COMP            reduce using rule 28 (list1 -> empty .)
    NE              reduce using rule 28 (list1 -> empty .)
    LTE             reduce using rule 28 (list1 -> empty .)
    GTE             reduce using rule 28 (list1 -> empty .)
    AND             reduce using rule 28 (list1 -> empty .)
    OR              reduce using rule 28 (list1 -> empty .)
    SEMI            reduce using rule 28 (list1 -> empty .)
    COMMA           reduce using rule 28 (list1 -> empty .)
    RP              reduce using rule 28 (list1 -> empty .)
    UNTIL           reduce using rule 28 (list1 -> empty .)
    DO              reduce using rule 28 (list1 -> empty .)


state 110

    (67) read -> READ LP . var read1 RP
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    ID              shift and go to state 134

    var                            shift and go to state 133

state 111

    (70) write -> WRITE LP . write1 RP
    (71) write1 -> . expression write2
    (72) write1 -> . CTES write2
    (81) expression -> . exp
    (82) expression -> . exp OR exp
    (83) exp -> . k_exp
    (84) exp -> . k_exp AND k_exp
    (85) k_exp -> . m_exp
    (86) k_exp -> . m_exp LT m_exp
    (87) k_exp -> . m_exp GT m_exp
    (88) k_exp -> . m_exp COMP m_exp
    (89) k_exp -> . m_exp NE m_exp
    (90) k_exp -> . m_exp LTE m_exp
    (91) k_exp -> . m_exp GTE m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    CTES            shift and go to state 137
    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    write1                         shift and go to state 135
    expression                     shift and go to state 136
    exp                            shift and go to state 120
    k_exp                          shift and go to state 121
    m_exp                          shift and go to state 122
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 112

    (75) if_st -> IF LP . expression RP THEN LB statement RB if1
    (81) expression -> . exp
    (82) expression -> . exp OR exp
    (83) exp -> . k_exp
    (84) exp -> . k_exp AND k_exp
    (85) k_exp -> . m_exp
    (86) k_exp -> . m_exp LT m_exp
    (87) k_exp -> . m_exp GT m_exp
    (88) k_exp -> . m_exp COMP m_exp
    (89) k_exp -> . m_exp NE m_exp
    (90) k_exp -> . m_exp LTE m_exp
    (91) k_exp -> . m_exp GTE m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    expression                     shift and go to state 138
    exp                            shift and go to state 120
    k_exp                          shift and go to state 121
    m_exp                          shift and go to state 122
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 113

    (78) while_st -> WHILE LP . expression RP DO LB main1 RB
    (81) expression -> . exp
    (82) expression -> . exp OR exp
    (83) exp -> . k_exp
    (84) exp -> . k_exp AND k_exp
    (85) k_exp -> . m_exp
    (86) k_exp -> . m_exp LT m_exp
    (87) k_exp -> . m_exp GT m_exp
    (88) k_exp -> . m_exp COMP m_exp
    (89) k_exp -> . m_exp NE m_exp
    (90) k_exp -> . m_exp LTE m_exp
    (91) k_exp -> . m_exp GTE m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    expression                     shift and go to state 139
    exp                            shift and go to state 120
    k_exp                          shift and go to state 121
    m_exp                          shift and go to state 122
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 114

    (79) from_st -> FROM ID . list1 EQ expression UNTIL expression DO LB main1 RB
    (26) list1 -> . LS CTEI RS
    (27) list1 -> . LS CTEI COMMA CTEI RS
    (28) list1 -> . empty
    (105) empty -> .

    LS              shift and go to state 37
    EQ              reduce using rule 105 (empty -> .)

    list1                          shift and go to state 140
    empty                          shift and go to state 38

state 115

    (80) return_st -> RETURN LP . expression RP
    (81) expression -> . exp
    (82) expression -> . exp OR exp
    (83) exp -> . k_exp
    (84) exp -> . k_exp AND k_exp
    (85) k_exp -> . m_exp
    (86) k_exp -> . m_exp LT m_exp
    (87) k_exp -> . m_exp GT m_exp
    (88) k_exp -> . m_exp COMP m_exp
    (89) k_exp -> . m_exp NE m_exp
    (90) k_exp -> . m_exp LTE m_exp
    (91) k_exp -> . m_exp GTE m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    expression                     shift and go to state 141
    exp                            shift and go to state 120
    k_exp                          shift and go to state 121
    m_exp                          shift and go to state 122
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 116

    (44) params -> ID COLON . tipo_param par1
    (41) tipo_param -> . INT
    (42) tipo_param -> . FLOAT
    (43) tipo_param -> . CHAR

    INT             shift and go to state 22
    FLOAT           shift and go to state 23
    CHAR            shift and go to state 24

    tipo_param                     shift and go to state 142

state 117

    (35) function -> tipo_retorno FUNCTION ID store_function LP func1 RP . LB func2 main1 RB

    LB              shift and go to state 143


state 118

    (101) fact -> var .

    MUL             reduce using rule 101 (fact -> var .)
    DIV             reduce using rule 101 (fact -> var .)
    PLUS            reduce using rule 101 (fact -> var .)
    MIN             reduce using rule 101 (fact -> var .)
    LT              reduce using rule 101 (fact -> var .)
    GT              reduce using rule 101 (fact -> var .)
    COMP            reduce using rule 101 (fact -> var .)
    NE              reduce using rule 101 (fact -> var .)
    LTE             reduce using rule 101 (fact -> var .)
    GTE             reduce using rule 101 (fact -> var .)
    AND             reduce using rule 101 (fact -> var .)
    OR              reduce using rule 101 (fact -> var .)
    SEMI            reduce using rule 101 (fact -> var .)
    COMMA           reduce using rule 101 (fact -> var .)
    RP              reduce using rule 101 (fact -> var .)
    UNTIL           reduce using rule 101 (fact -> var .)
    DO              reduce using rule 101 (fact -> var .)


state 119

    (58) assignment -> var EQ expression .

    SEMI            reduce using rule 58 (assignment -> var EQ expression .)


state 120

    (81) expression -> exp .
    (82) expression -> exp . OR exp

    SEMI            reduce using rule 81 (expression -> exp .)
    COMMA           reduce using rule 81 (expression -> exp .)
    RP              reduce using rule 81 (expression -> exp .)
    UNTIL           reduce using rule 81 (expression -> exp .)
    DO              reduce using rule 81 (expression -> exp .)
    OR              shift and go to state 144


state 121

    (83) exp -> k_exp .
    (84) exp -> k_exp . AND k_exp

    OR              reduce using rule 83 (exp -> k_exp .)
    SEMI            reduce using rule 83 (exp -> k_exp .)
    COMMA           reduce using rule 83 (exp -> k_exp .)
    RP              reduce using rule 83 (exp -> k_exp .)
    UNTIL           reduce using rule 83 (exp -> k_exp .)
    DO              reduce using rule 83 (exp -> k_exp .)
    AND             shift and go to state 145


state 122

    (85) k_exp -> m_exp .
    (86) k_exp -> m_exp . LT m_exp
    (87) k_exp -> m_exp . GT m_exp
    (88) k_exp -> m_exp . COMP m_exp
    (89) k_exp -> m_exp . NE m_exp
    (90) k_exp -> m_exp . LTE m_exp
    (91) k_exp -> m_exp . GTE m_exp

    AND             reduce using rule 85 (k_exp -> m_exp .)
    OR              reduce using rule 85 (k_exp -> m_exp .)
    SEMI            reduce using rule 85 (k_exp -> m_exp .)
    COMMA           reduce using rule 85 (k_exp -> m_exp .)
    RP              reduce using rule 85 (k_exp -> m_exp .)
    UNTIL           reduce using rule 85 (k_exp -> m_exp .)
    DO              reduce using rule 85 (k_exp -> m_exp .)
    LT              shift and go to state 146
    GT              shift and go to state 147
    COMP            shift and go to state 148
    NE              shift and go to state 149
    LTE             shift and go to state 150
    GTE             shift and go to state 151


state 123

    (92) m_exp -> term .
    (93) m_exp -> term . PLUS term
    (94) m_exp -> term . MIN term

    LT              reduce using rule 92 (m_exp -> term .)
    GT              reduce using rule 92 (m_exp -> term .)
    COMP            reduce using rule 92 (m_exp -> term .)
    NE              reduce using rule 92 (m_exp -> term .)
    LTE             reduce using rule 92 (m_exp -> term .)
    GTE             reduce using rule 92 (m_exp -> term .)
    AND             reduce using rule 92 (m_exp -> term .)
    OR              reduce using rule 92 (m_exp -> term .)
    SEMI            reduce using rule 92 (m_exp -> term .)
    COMMA           reduce using rule 92 (m_exp -> term .)
    RP              reduce using rule 92 (m_exp -> term .)
    UNTIL           reduce using rule 92 (m_exp -> term .)
    DO              reduce using rule 92 (m_exp -> term .)
    PLUS            shift and go to state 152
    MIN             shift and go to state 153


state 124

    (95) term -> fact .
    (96) term -> fact . MUL fact
    (97) term -> fact . DIV fact

    PLUS            reduce using rule 95 (term -> fact .)
    MIN             reduce using rule 95 (term -> fact .)
    LT              reduce using rule 95 (term -> fact .)
    GT              reduce using rule 95 (term -> fact .)
    COMP            reduce using rule 95 (term -> fact .)
    NE              reduce using rule 95 (term -> fact .)
    LTE             reduce using rule 95 (term -> fact .)
    GTE             reduce using rule 95 (term -> fact .)
    AND             reduce using rule 95 (term -> fact .)
    OR              reduce using rule 95 (term -> fact .)
    SEMI            reduce using rule 95 (term -> fact .)
    COMMA           reduce using rule 95 (term -> fact .)
    RP              reduce using rule 95 (term -> fact .)
    UNTIL           reduce using rule 95 (term -> fact .)
    DO              reduce using rule 95 (term -> fact .)
    MUL             shift and go to state 154
    DIV             shift and go to state 155


state 125

    (98) fact -> LP . expression RP
    (81) expression -> . exp
    (82) expression -> . exp OR exp
    (83) exp -> . k_exp
    (84) exp -> . k_exp AND k_exp
    (85) k_exp -> . m_exp
    (86) k_exp -> . m_exp LT m_exp
    (87) k_exp -> . m_exp GT m_exp
    (88) k_exp -> . m_exp COMP m_exp
    (89) k_exp -> . m_exp NE m_exp
    (90) k_exp -> . m_exp LTE m_exp
    (91) k_exp -> . m_exp GTE m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    expression                     shift and go to state 156
    exp                            shift and go to state 120
    k_exp                          shift and go to state 121
    m_exp                          shift and go to state 122
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 126

    (99) fact -> void_call .

    MUL             reduce using rule 99 (fact -> void_call .)
    DIV             reduce using rule 99 (fact -> void_call .)
    PLUS            reduce using rule 99 (fact -> void_call .)
    MIN             reduce using rule 99 (fact -> void_call .)
    LT              reduce using rule 99 (fact -> void_call .)
    GT              reduce using rule 99 (fact -> void_call .)
    COMP            reduce using rule 99 (fact -> void_call .)
    NE              reduce using rule 99 (fact -> void_call .)
    LTE             reduce using rule 99 (fact -> void_call .)
    GTE             reduce using rule 99 (fact -> void_call .)
    AND             reduce using rule 99 (fact -> void_call .)
    OR              reduce using rule 99 (fact -> void_call .)
    SEMI            reduce using rule 99 (fact -> void_call .)
    COMMA           reduce using rule 99 (fact -> void_call .)
    RP              reduce using rule 99 (fact -> void_call .)
    UNTIL           reduce using rule 99 (fact -> void_call .)
    DO              reduce using rule 99 (fact -> void_call .)


state 127

    (100) fact -> var_cte .

    MUL             reduce using rule 100 (fact -> var_cte .)
    DIV             reduce using rule 100 (fact -> var_cte .)
    PLUS            reduce using rule 100 (fact -> var_cte .)
    MIN             reduce using rule 100 (fact -> var_cte .)
    LT              reduce using rule 100 (fact -> var_cte .)
    GT              reduce using rule 100 (fact -> var_cte .)
    COMP            reduce using rule 100 (fact -> var_cte .)
    NE              reduce using rule 100 (fact -> var_cte .)
    LTE             reduce using rule 100 (fact -> var_cte .)
    GTE             reduce using rule 100 (fact -> var_cte .)
    AND             reduce using rule 100 (fact -> var_cte .)
    OR              reduce using rule 100 (fact -> var_cte .)
    SEMI            reduce using rule 100 (fact -> var_cte .)
    COMMA           reduce using rule 100 (fact -> var_cte .)
    RP              reduce using rule 100 (fact -> var_cte .)
    UNTIL           reduce using rule 100 (fact -> var_cte .)
    DO              reduce using rule 100 (fact -> var_cte .)


state 128

    (102) var_cte -> CTEI .

    MUL             reduce using rule 102 (var_cte -> CTEI .)
    DIV             reduce using rule 102 (var_cte -> CTEI .)
    PLUS            reduce using rule 102 (var_cte -> CTEI .)
    MIN             reduce using rule 102 (var_cte -> CTEI .)
    LT              reduce using rule 102 (var_cte -> CTEI .)
    GT              reduce using rule 102 (var_cte -> CTEI .)
    COMP            reduce using rule 102 (var_cte -> CTEI .)
    NE              reduce using rule 102 (var_cte -> CTEI .)
    LTE             reduce using rule 102 (var_cte -> CTEI .)
    GTE             reduce using rule 102 (var_cte -> CTEI .)
    AND             reduce using rule 102 (var_cte -> CTEI .)
    OR              reduce using rule 102 (var_cte -> CTEI .)
    SEMI            reduce using rule 102 (var_cte -> CTEI .)
    COMMA           reduce using rule 102 (var_cte -> CTEI .)
    RP              reduce using rule 102 (var_cte -> CTEI .)
    UNTIL           reduce using rule 102 (var_cte -> CTEI .)
    DO              reduce using rule 102 (var_cte -> CTEI .)


state 129

    (103) var_cte -> CTEF .

    MUL             reduce using rule 103 (var_cte -> CTEF .)
    DIV             reduce using rule 103 (var_cte -> CTEF .)
    PLUS            reduce using rule 103 (var_cte -> CTEF .)
    MIN             reduce using rule 103 (var_cte -> CTEF .)
    LT              reduce using rule 103 (var_cte -> CTEF .)
    GT              reduce using rule 103 (var_cte -> CTEF .)
    COMP            reduce using rule 103 (var_cte -> CTEF .)
    NE              reduce using rule 103 (var_cte -> CTEF .)
    LTE             reduce using rule 103 (var_cte -> CTEF .)
    GTE             reduce using rule 103 (var_cte -> CTEF .)
    AND             reduce using rule 103 (var_cte -> CTEF .)
    OR              reduce using rule 103 (var_cte -> CTEF .)
    SEMI            reduce using rule 103 (var_cte -> CTEF .)
    COMMA           reduce using rule 103 (var_cte -> CTEF .)
    RP              reduce using rule 103 (var_cte -> CTEF .)
    UNTIL           reduce using rule 103 (var_cte -> CTEF .)
    DO              reduce using rule 103 (var_cte -> CTEF .)


state 130

    (104) var_cte -> CTEC .

    MUL             reduce using rule 104 (var_cte -> CTEC .)
    DIV             reduce using rule 104 (var_cte -> CTEC .)
    PLUS            reduce using rule 104 (var_cte -> CTEC .)
    MIN             reduce using rule 104 (var_cte -> CTEC .)
    LT              reduce using rule 104 (var_cte -> CTEC .)
    GT              reduce using rule 104 (var_cte -> CTEC .)
    COMP            reduce using rule 104 (var_cte -> CTEC .)
    NE              reduce using rule 104 (var_cte -> CTEC .)
    LTE             reduce using rule 104 (var_cte -> CTEC .)
    GTE             reduce using rule 104 (var_cte -> CTEC .)
    AND             reduce using rule 104 (var_cte -> CTEC .)
    OR              reduce using rule 104 (var_cte -> CTEC .)
    SEMI            reduce using rule 104 (var_cte -> CTEC .)
    COMMA           reduce using rule 104 (var_cte -> CTEC .)
    RP              reduce using rule 104 (var_cte -> CTEC .)
    UNTIL           reduce using rule 104 (var_cte -> CTEC .)
    DO              reduce using rule 104 (var_cte -> CTEC .)


state 131

    (61) void_call -> ID call1 LP . call2 RP
    (62) void_call -> ID call1 LP . RP
    (65) call2 -> . expression
    (66) call2 -> . call2 COMMA call2
    (81) expression -> . exp
    (82) expression -> . exp OR exp
    (83) exp -> . k_exp
    (84) exp -> . k_exp AND k_exp
    (85) k_exp -> . m_exp
    (86) k_exp -> . m_exp LT m_exp
    (87) k_exp -> . m_exp GT m_exp
    (88) k_exp -> . m_exp COMP m_exp
    (89) k_exp -> . m_exp NE m_exp
    (90) k_exp -> . m_exp LTE m_exp
    (91) k_exp -> . m_exp GTE m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    RP              shift and go to state 158
    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    call2                          shift and go to state 157
    expression                     shift and go to state 159
    exp                            shift and go to state 120
    k_exp                          shift and go to state 121
    m_exp                          shift and go to state 122
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 132

    (60) var -> ID DOT ID .
    (63) call1 -> DOT ID .

    EQ              reduce using rule 60 (var -> ID DOT ID .)
    MUL             reduce using rule 60 (var -> ID DOT ID .)
    DIV             reduce using rule 60 (var -> ID DOT ID .)
    PLUS            reduce using rule 60 (var -> ID DOT ID .)
    MIN             reduce using rule 60 (var -> ID DOT ID .)
    LT              reduce using rule 60 (var -> ID DOT ID .)
    GT              reduce using rule 60 (var -> ID DOT ID .)
    COMP            reduce using rule 60 (var -> ID DOT ID .)
    NE              reduce using rule 60 (var -> ID DOT ID .)
    LTE             reduce using rule 60 (var -> ID DOT ID .)
    GTE             reduce using rule 60 (var -> ID DOT ID .)
    AND             reduce using rule 60 (var -> ID DOT ID .)
    OR              reduce using rule 60 (var -> ID DOT ID .)
    SEMI            reduce using rule 60 (var -> ID DOT ID .)
    COMMA           reduce using rule 60 (var -> ID DOT ID .)
    RP              reduce using rule 60 (var -> ID DOT ID .)
    UNTIL           reduce using rule 60 (var -> ID DOT ID .)
    DO              reduce using rule 60 (var -> ID DOT ID .)
    LP              reduce using rule 63 (call1 -> DOT ID .)


state 133

    (67) read -> READ LP var . read1 RP
    (68) read1 -> . COMMA var
    (69) read1 -> . empty
    (105) empty -> .

    COMMA           shift and go to state 161
    RP              reduce using rule 105 (empty -> .)

    read1                          shift and go to state 160
    empty                          shift and go to state 162

state 134

    (59) var -> ID . list1
    (60) var -> ID . DOT ID
    (26) list1 -> . LS CTEI RS
    (27) list1 -> . LS CTEI COMMA CTEI RS
    (28) list1 -> . empty
    (105) empty -> .

    DOT             shift and go to state 163
    LS              shift and go to state 37
    COMMA           reduce using rule 105 (empty -> .)
    RP              reduce using rule 105 (empty -> .)

    list1                          shift and go to state 107
    empty                          shift and go to state 38

state 135

    (70) write -> WRITE LP write1 . RP

    RP              shift and go to state 164


state 136

    (71) write1 -> expression . write2
    (73) write2 -> . COMMA write1
    (74) write2 -> . empty
    (105) empty -> .

    COMMA           shift and go to state 166
    RP              reduce using rule 105 (empty -> .)

    write2                         shift and go to state 165
    empty                          shift and go to state 167

state 137

    (72) write1 -> CTES . write2
    (73) write2 -> . COMMA write1
    (74) write2 -> . empty
    (105) empty -> .

    COMMA           shift and go to state 166
    RP              reduce using rule 105 (empty -> .)

    write2                         shift and go to state 168
    empty                          shift and go to state 167

state 138

    (75) if_st -> IF LP expression . RP THEN LB statement RB if1

    RP              shift and go to state 169


state 139

    (78) while_st -> WHILE LP expression . RP DO LB main1 RB

    RP              shift and go to state 170


state 140

    (79) from_st -> FROM ID list1 . EQ expression UNTIL expression DO LB main1 RB

    EQ              shift and go to state 171


state 141

    (80) return_st -> RETURN LP expression . RP

    RP              shift and go to state 172


state 142

    (44) params -> ID COLON tipo_param . par1
    (45) par1 -> . COMMA params
    (46) par1 -> . empty
    (105) empty -> .

    COMMA           shift and go to state 174
    RP              reduce using rule 105 (empty -> .)

    par1                           shift and go to state 173
    empty                          shift and go to state 175

state 143

    (35) function -> tipo_retorno FUNCTION ID store_function LP func1 RP LB . func2 main1 RB
    (39) func2 -> . vars
    (40) func2 -> . empty
    (22) vars -> . VARIABLES attrs1
    (105) empty -> .

    VARIABLES       shift and go to state 13
    ID              reduce using rule 105 (empty -> .)
    READ            reduce using rule 105 (empty -> .)
    WRITE           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FROM            reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)
    RB              reduce using rule 105 (empty -> .)

    func2                          shift and go to state 176
    vars                           shift and go to state 177
    empty                          shift and go to state 178

state 144

    (82) expression -> exp OR . exp
    (83) exp -> . k_exp
    (84) exp -> . k_exp AND k_exp
    (85) k_exp -> . m_exp
    (86) k_exp -> . m_exp LT m_exp
    (87) k_exp -> . m_exp GT m_exp
    (88) k_exp -> . m_exp COMP m_exp
    (89) k_exp -> . m_exp NE m_exp
    (90) k_exp -> . m_exp LTE m_exp
    (91) k_exp -> . m_exp GTE m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    exp                            shift and go to state 179
    k_exp                          shift and go to state 121
    m_exp                          shift and go to state 122
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 145

    (84) exp -> k_exp AND . k_exp
    (85) k_exp -> . m_exp
    (86) k_exp -> . m_exp LT m_exp
    (87) k_exp -> . m_exp GT m_exp
    (88) k_exp -> . m_exp COMP m_exp
    (89) k_exp -> . m_exp NE m_exp
    (90) k_exp -> . m_exp LTE m_exp
    (91) k_exp -> . m_exp GTE m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    k_exp                          shift and go to state 180
    m_exp                          shift and go to state 122
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 146

    (86) k_exp -> m_exp LT . m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    m_exp                          shift and go to state 181
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 147

    (87) k_exp -> m_exp GT . m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    m_exp                          shift and go to state 182
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 148

    (88) k_exp -> m_exp COMP . m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    m_exp                          shift and go to state 183
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 149

    (89) k_exp -> m_exp NE . m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    m_exp                          shift and go to state 184
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 150

    (90) k_exp -> m_exp LTE . m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    m_exp                          shift and go to state 185
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 151

    (91) k_exp -> m_exp GTE . m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    m_exp                          shift and go to state 186
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 152

    (93) m_exp -> term PLUS . term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    term                           shift and go to state 187
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 153

    (94) m_exp -> term MIN . term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    term                           shift and go to state 188
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 154

    (96) term -> fact MUL . fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    fact                           shift and go to state 189
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 155

    (97) term -> fact DIV . fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    fact                           shift and go to state 190
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 156

    (98) fact -> LP expression . RP

    RP              shift and go to state 191


state 157

    (61) void_call -> ID call1 LP call2 . RP
    (66) call2 -> call2 . COMMA call2

    RP              shift and go to state 192
    COMMA           shift and go to state 193


state 158

    (62) void_call -> ID call1 LP RP .

    SEMI            reduce using rule 62 (void_call -> ID call1 LP RP .)
    MUL             reduce using rule 62 (void_call -> ID call1 LP RP .)
    DIV             reduce using rule 62 (void_call -> ID call1 LP RP .)
    PLUS            reduce using rule 62 (void_call -> ID call1 LP RP .)
    MIN             reduce using rule 62 (void_call -> ID call1 LP RP .)
    LT              reduce using rule 62 (void_call -> ID call1 LP RP .)
    GT              reduce using rule 62 (void_call -> ID call1 LP RP .)
    COMP            reduce using rule 62 (void_call -> ID call1 LP RP .)
    NE              reduce using rule 62 (void_call -> ID call1 LP RP .)
    LTE             reduce using rule 62 (void_call -> ID call1 LP RP .)
    GTE             reduce using rule 62 (void_call -> ID call1 LP RP .)
    AND             reduce using rule 62 (void_call -> ID call1 LP RP .)
    OR              reduce using rule 62 (void_call -> ID call1 LP RP .)
    COMMA           reduce using rule 62 (void_call -> ID call1 LP RP .)
    RP              reduce using rule 62 (void_call -> ID call1 LP RP .)
    UNTIL           reduce using rule 62 (void_call -> ID call1 LP RP .)
    DO              reduce using rule 62 (void_call -> ID call1 LP RP .)


state 159

    (65) call2 -> expression .

    RP              reduce using rule 65 (call2 -> expression .)
    COMMA           reduce using rule 65 (call2 -> expression .)


state 160

    (67) read -> READ LP var read1 . RP

    RP              shift and go to state 194


state 161

    (68) read1 -> COMMA . var
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    ID              shift and go to state 134

    var                            shift and go to state 195

state 162

    (69) read1 -> empty .

    RP              reduce using rule 69 (read1 -> empty .)


state 163

    (60) var -> ID DOT . ID

    ID              shift and go to state 196


state 164

    (70) write -> WRITE LP write1 RP .

    SEMI            reduce using rule 70 (write -> WRITE LP write1 RP .)


state 165

    (71) write1 -> expression write2 .

    RP              reduce using rule 71 (write1 -> expression write2 .)


state 166

    (73) write2 -> COMMA . write1
    (71) write1 -> . expression write2
    (72) write1 -> . CTES write2
    (81) expression -> . exp
    (82) expression -> . exp OR exp
    (83) exp -> . k_exp
    (84) exp -> . k_exp AND k_exp
    (85) k_exp -> . m_exp
    (86) k_exp -> . m_exp LT m_exp
    (87) k_exp -> . m_exp GT m_exp
    (88) k_exp -> . m_exp COMP m_exp
    (89) k_exp -> . m_exp NE m_exp
    (90) k_exp -> . m_exp LTE m_exp
    (91) k_exp -> . m_exp GTE m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    CTES            shift and go to state 137
    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    write1                         shift and go to state 197
    expression                     shift and go to state 136
    exp                            shift and go to state 120
    k_exp                          shift and go to state 121
    m_exp                          shift and go to state 122
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 167

    (74) write2 -> empty .

    RP              reduce using rule 74 (write2 -> empty .)


state 168

    (72) write1 -> CTES write2 .

    RP              reduce using rule 72 (write1 -> CTES write2 .)


state 169

    (75) if_st -> IF LP expression RP . THEN LB statement RB if1

    THEN            shift and go to state 198


state 170

    (78) while_st -> WHILE LP expression RP . DO LB main1 RB

    DO              shift and go to state 199


state 171

    (79) from_st -> FROM ID list1 EQ . expression UNTIL expression DO LB main1 RB
    (81) expression -> . exp
    (82) expression -> . exp OR exp
    (83) exp -> . k_exp
    (84) exp -> . k_exp AND k_exp
    (85) k_exp -> . m_exp
    (86) k_exp -> . m_exp LT m_exp
    (87) k_exp -> . m_exp GT m_exp
    (88) k_exp -> . m_exp COMP m_exp
    (89) k_exp -> . m_exp NE m_exp
    (90) k_exp -> . m_exp LTE m_exp
    (91) k_exp -> . m_exp GTE m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    expression                     shift and go to state 200
    exp                            shift and go to state 120
    k_exp                          shift and go to state 121
    m_exp                          shift and go to state 122
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 172

    (80) return_st -> RETURN LP expression RP .

    SEMI            reduce using rule 80 (return_st -> RETURN LP expression RP .)


state 173

    (44) params -> ID COLON tipo_param par1 .

    RP              reduce using rule 44 (params -> ID COLON tipo_param par1 .)


state 174

    (45) par1 -> COMMA . params
    (44) params -> . ID COLON tipo_param par1

    ID              shift and go to state 92

    params                         shift and go to state 201

state 175

    (46) par1 -> empty .

    RP              reduce using rule 46 (par1 -> empty .)


state 176

    (35) function -> tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 . main1 RB
    (32) main1 -> . statement
    (33) main1 -> . empty
    (49) statement -> . statement statement
    (50) statement -> . assignment SEMI
    (51) statement -> . void_call SEMI
    (52) statement -> . read SEMI
    (53) statement -> . write SEMI
    (54) statement -> . if_st
    (55) statement -> . while_st
    (56) statement -> . from_st
    (57) statement -> . return_st SEMI
    (105) empty -> .
    (58) assignment -> . var EQ expression
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (67) read -> . READ LP var read1 RP
    (70) write -> . WRITE LP write1 RP
    (75) if_st -> . IF LP expression RP THEN LB statement RB if1
    (78) while_st -> . WHILE LP expression RP DO LB main1 RB
    (79) from_st -> . FROM ID list1 EQ expression UNTIL expression DO LB main1 RB
    (80) return_st -> . RETURN LP expression RP
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    RB              reduce using rule 105 (empty -> .)
    ID              shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    WHILE           shift and go to state 89
    FROM            shift and go to state 90
    RETURN          shift and go to state 91

    main1                          shift and go to state 202
    statement                      shift and go to state 74
    empty                          shift and go to state 75
    assignment                     shift and go to state 76
    void_call                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    if_st                          shift and go to state 80
    while_st                       shift and go to state 81
    from_st                        shift and go to state 82
    return_st                      shift and go to state 83
    var                            shift and go to state 84

state 177

    (39) func2 -> vars .

    ID              reduce using rule 39 (func2 -> vars .)
    READ            reduce using rule 39 (func2 -> vars .)
    WRITE           reduce using rule 39 (func2 -> vars .)
    IF              reduce using rule 39 (func2 -> vars .)
    WHILE           reduce using rule 39 (func2 -> vars .)
    FROM            reduce using rule 39 (func2 -> vars .)
    RETURN          reduce using rule 39 (func2 -> vars .)
    RB              reduce using rule 39 (func2 -> vars .)


state 178

    (40) func2 -> empty .

    ID              reduce using rule 40 (func2 -> empty .)
    READ            reduce using rule 40 (func2 -> empty .)
    WRITE           reduce using rule 40 (func2 -> empty .)
    IF              reduce using rule 40 (func2 -> empty .)
    WHILE           reduce using rule 40 (func2 -> empty .)
    FROM            reduce using rule 40 (func2 -> empty .)
    RETURN          reduce using rule 40 (func2 -> empty .)
    RB              reduce using rule 40 (func2 -> empty .)


state 179

    (82) expression -> exp OR exp .

    SEMI            reduce using rule 82 (expression -> exp OR exp .)
    COMMA           reduce using rule 82 (expression -> exp OR exp .)
    RP              reduce using rule 82 (expression -> exp OR exp .)
    UNTIL           reduce using rule 82 (expression -> exp OR exp .)
    DO              reduce using rule 82 (expression -> exp OR exp .)


state 180

    (84) exp -> k_exp AND k_exp .

    OR              reduce using rule 84 (exp -> k_exp AND k_exp .)
    SEMI            reduce using rule 84 (exp -> k_exp AND k_exp .)
    COMMA           reduce using rule 84 (exp -> k_exp AND k_exp .)
    RP              reduce using rule 84 (exp -> k_exp AND k_exp .)
    UNTIL           reduce using rule 84 (exp -> k_exp AND k_exp .)
    DO              reduce using rule 84 (exp -> k_exp AND k_exp .)


state 181

    (86) k_exp -> m_exp LT m_exp .

    AND             reduce using rule 86 (k_exp -> m_exp LT m_exp .)
    OR              reduce using rule 86 (k_exp -> m_exp LT m_exp .)
    SEMI            reduce using rule 86 (k_exp -> m_exp LT m_exp .)
    COMMA           reduce using rule 86 (k_exp -> m_exp LT m_exp .)
    RP              reduce using rule 86 (k_exp -> m_exp LT m_exp .)
    UNTIL           reduce using rule 86 (k_exp -> m_exp LT m_exp .)
    DO              reduce using rule 86 (k_exp -> m_exp LT m_exp .)


state 182

    (87) k_exp -> m_exp GT m_exp .

    AND             reduce using rule 87 (k_exp -> m_exp GT m_exp .)
    OR              reduce using rule 87 (k_exp -> m_exp GT m_exp .)
    SEMI            reduce using rule 87 (k_exp -> m_exp GT m_exp .)
    COMMA           reduce using rule 87 (k_exp -> m_exp GT m_exp .)
    RP              reduce using rule 87 (k_exp -> m_exp GT m_exp .)
    UNTIL           reduce using rule 87 (k_exp -> m_exp GT m_exp .)
    DO              reduce using rule 87 (k_exp -> m_exp GT m_exp .)


state 183

    (88) k_exp -> m_exp COMP m_exp .

    AND             reduce using rule 88 (k_exp -> m_exp COMP m_exp .)
    OR              reduce using rule 88 (k_exp -> m_exp COMP m_exp .)
    SEMI            reduce using rule 88 (k_exp -> m_exp COMP m_exp .)
    COMMA           reduce using rule 88 (k_exp -> m_exp COMP m_exp .)
    RP              reduce using rule 88 (k_exp -> m_exp COMP m_exp .)
    UNTIL           reduce using rule 88 (k_exp -> m_exp COMP m_exp .)
    DO              reduce using rule 88 (k_exp -> m_exp COMP m_exp .)


state 184

    (89) k_exp -> m_exp NE m_exp .

    AND             reduce using rule 89 (k_exp -> m_exp NE m_exp .)
    OR              reduce using rule 89 (k_exp -> m_exp NE m_exp .)
    SEMI            reduce using rule 89 (k_exp -> m_exp NE m_exp .)
    COMMA           reduce using rule 89 (k_exp -> m_exp NE m_exp .)
    RP              reduce using rule 89 (k_exp -> m_exp NE m_exp .)
    UNTIL           reduce using rule 89 (k_exp -> m_exp NE m_exp .)
    DO              reduce using rule 89 (k_exp -> m_exp NE m_exp .)


state 185

    (90) k_exp -> m_exp LTE m_exp .

    AND             reduce using rule 90 (k_exp -> m_exp LTE m_exp .)
    OR              reduce using rule 90 (k_exp -> m_exp LTE m_exp .)
    SEMI            reduce using rule 90 (k_exp -> m_exp LTE m_exp .)
    COMMA           reduce using rule 90 (k_exp -> m_exp LTE m_exp .)
    RP              reduce using rule 90 (k_exp -> m_exp LTE m_exp .)
    UNTIL           reduce using rule 90 (k_exp -> m_exp LTE m_exp .)
    DO              reduce using rule 90 (k_exp -> m_exp LTE m_exp .)


state 186

    (91) k_exp -> m_exp GTE m_exp .

    AND             reduce using rule 91 (k_exp -> m_exp GTE m_exp .)
    OR              reduce using rule 91 (k_exp -> m_exp GTE m_exp .)
    SEMI            reduce using rule 91 (k_exp -> m_exp GTE m_exp .)
    COMMA           reduce using rule 91 (k_exp -> m_exp GTE m_exp .)
    RP              reduce using rule 91 (k_exp -> m_exp GTE m_exp .)
    UNTIL           reduce using rule 91 (k_exp -> m_exp GTE m_exp .)
    DO              reduce using rule 91 (k_exp -> m_exp GTE m_exp .)


state 187

    (93) m_exp -> term PLUS term .

    LT              reduce using rule 93 (m_exp -> term PLUS term .)
    GT              reduce using rule 93 (m_exp -> term PLUS term .)
    COMP            reduce using rule 93 (m_exp -> term PLUS term .)
    NE              reduce using rule 93 (m_exp -> term PLUS term .)
    LTE             reduce using rule 93 (m_exp -> term PLUS term .)
    GTE             reduce using rule 93 (m_exp -> term PLUS term .)
    AND             reduce using rule 93 (m_exp -> term PLUS term .)
    OR              reduce using rule 93 (m_exp -> term PLUS term .)
    SEMI            reduce using rule 93 (m_exp -> term PLUS term .)
    COMMA           reduce using rule 93 (m_exp -> term PLUS term .)
    RP              reduce using rule 93 (m_exp -> term PLUS term .)
    UNTIL           reduce using rule 93 (m_exp -> term PLUS term .)
    DO              reduce using rule 93 (m_exp -> term PLUS term .)


state 188

    (94) m_exp -> term MIN term .

    LT              reduce using rule 94 (m_exp -> term MIN term .)
    GT              reduce using rule 94 (m_exp -> term MIN term .)
    COMP            reduce using rule 94 (m_exp -> term MIN term .)
    NE              reduce using rule 94 (m_exp -> term MIN term .)
    LTE             reduce using rule 94 (m_exp -> term MIN term .)
    GTE             reduce using rule 94 (m_exp -> term MIN term .)
    AND             reduce using rule 94 (m_exp -> term MIN term .)
    OR              reduce using rule 94 (m_exp -> term MIN term .)
    SEMI            reduce using rule 94 (m_exp -> term MIN term .)
    COMMA           reduce using rule 94 (m_exp -> term MIN term .)
    RP              reduce using rule 94 (m_exp -> term MIN term .)
    UNTIL           reduce using rule 94 (m_exp -> term MIN term .)
    DO              reduce using rule 94 (m_exp -> term MIN term .)


state 189

    (96) term -> fact MUL fact .

    PLUS            reduce using rule 96 (term -> fact MUL fact .)
    MIN             reduce using rule 96 (term -> fact MUL fact .)
    LT              reduce using rule 96 (term -> fact MUL fact .)
    GT              reduce using rule 96 (term -> fact MUL fact .)
    COMP            reduce using rule 96 (term -> fact MUL fact .)
    NE              reduce using rule 96 (term -> fact MUL fact .)
    LTE             reduce using rule 96 (term -> fact MUL fact .)
    GTE             reduce using rule 96 (term -> fact MUL fact .)
    AND             reduce using rule 96 (term -> fact MUL fact .)
    OR              reduce using rule 96 (term -> fact MUL fact .)
    SEMI            reduce using rule 96 (term -> fact MUL fact .)
    COMMA           reduce using rule 96 (term -> fact MUL fact .)
    RP              reduce using rule 96 (term -> fact MUL fact .)
    UNTIL           reduce using rule 96 (term -> fact MUL fact .)
    DO              reduce using rule 96 (term -> fact MUL fact .)


state 190

    (97) term -> fact DIV fact .

    PLUS            reduce using rule 97 (term -> fact DIV fact .)
    MIN             reduce using rule 97 (term -> fact DIV fact .)
    LT              reduce using rule 97 (term -> fact DIV fact .)
    GT              reduce using rule 97 (term -> fact DIV fact .)
    COMP            reduce using rule 97 (term -> fact DIV fact .)
    NE              reduce using rule 97 (term -> fact DIV fact .)
    LTE             reduce using rule 97 (term -> fact DIV fact .)
    GTE             reduce using rule 97 (term -> fact DIV fact .)
    AND             reduce using rule 97 (term -> fact DIV fact .)
    OR              reduce using rule 97 (term -> fact DIV fact .)
    SEMI            reduce using rule 97 (term -> fact DIV fact .)
    COMMA           reduce using rule 97 (term -> fact DIV fact .)
    RP              reduce using rule 97 (term -> fact DIV fact .)
    UNTIL           reduce using rule 97 (term -> fact DIV fact .)
    DO              reduce using rule 97 (term -> fact DIV fact .)


state 191

    (98) fact -> LP expression RP .

    MUL             reduce using rule 98 (fact -> LP expression RP .)
    DIV             reduce using rule 98 (fact -> LP expression RP .)
    PLUS            reduce using rule 98 (fact -> LP expression RP .)
    MIN             reduce using rule 98 (fact -> LP expression RP .)
    LT              reduce using rule 98 (fact -> LP expression RP .)
    GT              reduce using rule 98 (fact -> LP expression RP .)
    COMP            reduce using rule 98 (fact -> LP expression RP .)
    NE              reduce using rule 98 (fact -> LP expression RP .)
    LTE             reduce using rule 98 (fact -> LP expression RP .)
    GTE             reduce using rule 98 (fact -> LP expression RP .)
    AND             reduce using rule 98 (fact -> LP expression RP .)
    OR              reduce using rule 98 (fact -> LP expression RP .)
    SEMI            reduce using rule 98 (fact -> LP expression RP .)
    COMMA           reduce using rule 98 (fact -> LP expression RP .)
    RP              reduce using rule 98 (fact -> LP expression RP .)
    UNTIL           reduce using rule 98 (fact -> LP expression RP .)
    DO              reduce using rule 98 (fact -> LP expression RP .)


state 192

    (61) void_call -> ID call1 LP call2 RP .

    SEMI            reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    MUL             reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    DIV             reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    PLUS            reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    MIN             reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    LT              reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    GT              reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    COMP            reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    NE              reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    LTE             reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    GTE             reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    AND             reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    OR              reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    COMMA           reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    RP              reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    UNTIL           reduce using rule 61 (void_call -> ID call1 LP call2 RP .)
    DO              reduce using rule 61 (void_call -> ID call1 LP call2 RP .)


state 193

    (66) call2 -> call2 COMMA . call2
    (65) call2 -> . expression
    (66) call2 -> . call2 COMMA call2
    (81) expression -> . exp
    (82) expression -> . exp OR exp
    (83) exp -> . k_exp
    (84) exp -> . k_exp AND k_exp
    (85) k_exp -> . m_exp
    (86) k_exp -> . m_exp LT m_exp
    (87) k_exp -> . m_exp GT m_exp
    (88) k_exp -> . m_exp COMP m_exp
    (89) k_exp -> . m_exp NE m_exp
    (90) k_exp -> . m_exp LTE m_exp
    (91) k_exp -> . m_exp GTE m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    call2                          shift and go to state 203
    expression                     shift and go to state 159
    exp                            shift and go to state 120
    k_exp                          shift and go to state 121
    m_exp                          shift and go to state 122
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 194

    (67) read -> READ LP var read1 RP .

    SEMI            reduce using rule 67 (read -> READ LP var read1 RP .)


state 195

    (68) read1 -> COMMA var .

    RP              reduce using rule 68 (read1 -> COMMA var .)


state 196

    (60) var -> ID DOT ID .

    COMMA           reduce using rule 60 (var -> ID DOT ID .)
    RP              reduce using rule 60 (var -> ID DOT ID .)


state 197

    (73) write2 -> COMMA write1 .

    RP              reduce using rule 73 (write2 -> COMMA write1 .)


state 198

    (75) if_st -> IF LP expression RP THEN . LB statement RB if1

    LB              shift and go to state 204


state 199

    (78) while_st -> WHILE LP expression RP DO . LB main1 RB

    LB              shift and go to state 205


state 200

    (79) from_st -> FROM ID list1 EQ expression . UNTIL expression DO LB main1 RB

    UNTIL           shift and go to state 206


state 201

    (45) par1 -> COMMA params .

    RP              reduce using rule 45 (par1 -> COMMA params .)


state 202

    (35) function -> tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 main1 . RB

    RB              shift and go to state 207


state 203

    (66) call2 -> call2 COMMA call2 .
    (66) call2 -> call2 . COMMA call2

  ! shift/reduce conflict for COMMA resolved as shift
    RP              reduce using rule 66 (call2 -> call2 COMMA call2 .)
    COMMA           shift and go to state 193

  ! COMMA           [ reduce using rule 66 (call2 -> call2 COMMA call2 .) ]


state 204

    (75) if_st -> IF LP expression RP THEN LB . statement RB if1
    (49) statement -> . statement statement
    (50) statement -> . assignment SEMI
    (51) statement -> . void_call SEMI
    (52) statement -> . read SEMI
    (53) statement -> . write SEMI
    (54) statement -> . if_st
    (55) statement -> . while_st
    (56) statement -> . from_st
    (57) statement -> . return_st SEMI
    (58) assignment -> . var EQ expression
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (67) read -> . READ LP var read1 RP
    (70) write -> . WRITE LP write1 RP
    (75) if_st -> . IF LP expression RP THEN LB statement RB if1
    (78) while_st -> . WHILE LP expression RP DO LB main1 RB
    (79) from_st -> . FROM ID list1 EQ expression UNTIL expression DO LB main1 RB
    (80) return_st -> . RETURN LP expression RP
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    ID              shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    WHILE           shift and go to state 89
    FROM            shift and go to state 90
    RETURN          shift and go to state 91

    statement                      shift and go to state 208
    assignment                     shift and go to state 76
    void_call                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    if_st                          shift and go to state 80
    while_st                       shift and go to state 81
    from_st                        shift and go to state 82
    return_st                      shift and go to state 83
    var                            shift and go to state 84

state 205

    (78) while_st -> WHILE LP expression RP DO LB . main1 RB
    (32) main1 -> . statement
    (33) main1 -> . empty
    (49) statement -> . statement statement
    (50) statement -> . assignment SEMI
    (51) statement -> . void_call SEMI
    (52) statement -> . read SEMI
    (53) statement -> . write SEMI
    (54) statement -> . if_st
    (55) statement -> . while_st
    (56) statement -> . from_st
    (57) statement -> . return_st SEMI
    (105) empty -> .
    (58) assignment -> . var EQ expression
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (67) read -> . READ LP var read1 RP
    (70) write -> . WRITE LP write1 RP
    (75) if_st -> . IF LP expression RP THEN LB statement RB if1
    (78) while_st -> . WHILE LP expression RP DO LB main1 RB
    (79) from_st -> . FROM ID list1 EQ expression UNTIL expression DO LB main1 RB
    (80) return_st -> . RETURN LP expression RP
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    RB              reduce using rule 105 (empty -> .)
    ID              shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    WHILE           shift and go to state 89
    FROM            shift and go to state 90
    RETURN          shift and go to state 91

    main1                          shift and go to state 209
    statement                      shift and go to state 74
    empty                          shift and go to state 75
    assignment                     shift and go to state 76
    void_call                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    if_st                          shift and go to state 80
    while_st                       shift and go to state 81
    from_st                        shift and go to state 82
    return_st                      shift and go to state 83
    var                            shift and go to state 84

state 206

    (79) from_st -> FROM ID list1 EQ expression UNTIL . expression DO LB main1 RB
    (81) expression -> . exp
    (82) expression -> . exp OR exp
    (83) exp -> . k_exp
    (84) exp -> . k_exp AND k_exp
    (85) k_exp -> . m_exp
    (86) k_exp -> . m_exp LT m_exp
    (87) k_exp -> . m_exp GT m_exp
    (88) k_exp -> . m_exp COMP m_exp
    (89) k_exp -> . m_exp NE m_exp
    (90) k_exp -> . m_exp LTE m_exp
    (91) k_exp -> . m_exp GTE m_exp
    (92) m_exp -> . term
    (93) m_exp -> . term PLUS term
    (94) m_exp -> . term MIN term
    (95) term -> . fact
    (96) term -> . fact MUL fact
    (97) term -> . fact DIV fact
    (98) fact -> . LP expression RP
    (99) fact -> . void_call
    (100) fact -> . var_cte
    (101) fact -> . var
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (102) var_cte -> . CTEI
    (103) var_cte -> . CTEF
    (104) var_cte -> . CTEC
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    LP              shift and go to state 125
    ID              shift and go to state 85
    CTEI            shift and go to state 128
    CTEF            shift and go to state 129
    CTEC            shift and go to state 130

    expression                     shift and go to state 210
    exp                            shift and go to state 120
    k_exp                          shift and go to state 121
    m_exp                          shift and go to state 122
    term                           shift and go to state 123
    fact                           shift and go to state 124
    void_call                      shift and go to state 126
    var_cte                        shift and go to state 127
    var                            shift and go to state 118

state 207

    (35) function -> tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 main1 RB .

    VOID            reduce using rule 35 (function -> tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 main1 RB .)
    INT             reduce using rule 35 (function -> tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 main1 RB .)
    FLOAT           reduce using rule 35 (function -> tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 main1 RB .)
    CHAR            reduce using rule 35 (function -> tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 main1 RB .)
    MAIN            reduce using rule 35 (function -> tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 main1 RB .)
    RB              reduce using rule 35 (function -> tipo_retorno FUNCTION ID store_function LP func1 RP LB func2 main1 RB .)


state 208

    (75) if_st -> IF LP expression RP THEN LB statement . RB if1
    (49) statement -> statement . statement
    (49) statement -> . statement statement
    (50) statement -> . assignment SEMI
    (51) statement -> . void_call SEMI
    (52) statement -> . read SEMI
    (53) statement -> . write SEMI
    (54) statement -> . if_st
    (55) statement -> . while_st
    (56) statement -> . from_st
    (57) statement -> . return_st SEMI
    (58) assignment -> . var EQ expression
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (67) read -> . READ LP var read1 RP
    (70) write -> . WRITE LP write1 RP
    (75) if_st -> . IF LP expression RP THEN LB statement RB if1
    (78) while_st -> . WHILE LP expression RP DO LB main1 RB
    (79) from_st -> . FROM ID list1 EQ expression UNTIL expression DO LB main1 RB
    (80) return_st -> . RETURN LP expression RP
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    RB              shift and go to state 211
    ID              shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    WHILE           shift and go to state 89
    FROM            shift and go to state 90
    RETURN          shift and go to state 91

    statement                      shift and go to state 99
    assignment                     shift and go to state 76
    void_call                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    if_st                          shift and go to state 80
    while_st                       shift and go to state 81
    from_st                        shift and go to state 82
    return_st                      shift and go to state 83
    var                            shift and go to state 84

state 209

    (78) while_st -> WHILE LP expression RP DO LB main1 . RB

    RB              shift and go to state 212


state 210

    (79) from_st -> FROM ID list1 EQ expression UNTIL expression . DO LB main1 RB

    DO              shift and go to state 213


state 211

    (75) if_st -> IF LP expression RP THEN LB statement RB . if1
    (76) if1 -> . ELSE LB main1 RB
    (77) if1 -> . empty
    (105) empty -> .

    ELSE            shift and go to state 215
    ID              reduce using rule 105 (empty -> .)
    READ            reduce using rule 105 (empty -> .)
    WRITE           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FROM            reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)
    RB              reduce using rule 105 (empty -> .)

    if1                            shift and go to state 214
    empty                          shift and go to state 216

state 212

    (78) while_st -> WHILE LP expression RP DO LB main1 RB .

    ID              reduce using rule 78 (while_st -> WHILE LP expression RP DO LB main1 RB .)
    READ            reduce using rule 78 (while_st -> WHILE LP expression RP DO LB main1 RB .)
    WRITE           reduce using rule 78 (while_st -> WHILE LP expression RP DO LB main1 RB .)
    IF              reduce using rule 78 (while_st -> WHILE LP expression RP DO LB main1 RB .)
    WHILE           reduce using rule 78 (while_st -> WHILE LP expression RP DO LB main1 RB .)
    FROM            reduce using rule 78 (while_st -> WHILE LP expression RP DO LB main1 RB .)
    RETURN          reduce using rule 78 (while_st -> WHILE LP expression RP DO LB main1 RB .)
    RB              reduce using rule 78 (while_st -> WHILE LP expression RP DO LB main1 RB .)


state 213

    (79) from_st -> FROM ID list1 EQ expression UNTIL expression DO . LB main1 RB

    LB              shift and go to state 217


state 214

    (75) if_st -> IF LP expression RP THEN LB statement RB if1 .

    ID              reduce using rule 75 (if_st -> IF LP expression RP THEN LB statement RB if1 .)
    READ            reduce using rule 75 (if_st -> IF LP expression RP THEN LB statement RB if1 .)
    WRITE           reduce using rule 75 (if_st -> IF LP expression RP THEN LB statement RB if1 .)
    IF              reduce using rule 75 (if_st -> IF LP expression RP THEN LB statement RB if1 .)
    WHILE           reduce using rule 75 (if_st -> IF LP expression RP THEN LB statement RB if1 .)
    FROM            reduce using rule 75 (if_st -> IF LP expression RP THEN LB statement RB if1 .)
    RETURN          reduce using rule 75 (if_st -> IF LP expression RP THEN LB statement RB if1 .)
    RB              reduce using rule 75 (if_st -> IF LP expression RP THEN LB statement RB if1 .)


state 215

    (76) if1 -> ELSE . LB main1 RB

    LB              shift and go to state 218


state 216

    (77) if1 -> empty .

    ID              reduce using rule 77 (if1 -> empty .)
    READ            reduce using rule 77 (if1 -> empty .)
    WRITE           reduce using rule 77 (if1 -> empty .)
    IF              reduce using rule 77 (if1 -> empty .)
    WHILE           reduce using rule 77 (if1 -> empty .)
    FROM            reduce using rule 77 (if1 -> empty .)
    RETURN          reduce using rule 77 (if1 -> empty .)
    RB              reduce using rule 77 (if1 -> empty .)


state 217

    (79) from_st -> FROM ID list1 EQ expression UNTIL expression DO LB . main1 RB
    (32) main1 -> . statement
    (33) main1 -> . empty
    (49) statement -> . statement statement
    (50) statement -> . assignment SEMI
    (51) statement -> . void_call SEMI
    (52) statement -> . read SEMI
    (53) statement -> . write SEMI
    (54) statement -> . if_st
    (55) statement -> . while_st
    (56) statement -> . from_st
    (57) statement -> . return_st SEMI
    (105) empty -> .
    (58) assignment -> . var EQ expression
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (67) read -> . READ LP var read1 RP
    (70) write -> . WRITE LP write1 RP
    (75) if_st -> . IF LP expression RP THEN LB statement RB if1
    (78) while_st -> . WHILE LP expression RP DO LB main1 RB
    (79) from_st -> . FROM ID list1 EQ expression UNTIL expression DO LB main1 RB
    (80) return_st -> . RETURN LP expression RP
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    RB              reduce using rule 105 (empty -> .)
    ID              shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    WHILE           shift and go to state 89
    FROM            shift and go to state 90
    RETURN          shift and go to state 91

    main1                          shift and go to state 219
    statement                      shift and go to state 74
    empty                          shift and go to state 75
    assignment                     shift and go to state 76
    void_call                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    if_st                          shift and go to state 80
    while_st                       shift and go to state 81
    from_st                        shift and go to state 82
    return_st                      shift and go to state 83
    var                            shift and go to state 84

state 218

    (76) if1 -> ELSE LB . main1 RB
    (32) main1 -> . statement
    (33) main1 -> . empty
    (49) statement -> . statement statement
    (50) statement -> . assignment SEMI
    (51) statement -> . void_call SEMI
    (52) statement -> . read SEMI
    (53) statement -> . write SEMI
    (54) statement -> . if_st
    (55) statement -> . while_st
    (56) statement -> . from_st
    (57) statement -> . return_st SEMI
    (105) empty -> .
    (58) assignment -> . var EQ expression
    (61) void_call -> . ID call1 LP call2 RP
    (62) void_call -> . ID call1 LP RP
    (67) read -> . READ LP var read1 RP
    (70) write -> . WRITE LP write1 RP
    (75) if_st -> . IF LP expression RP THEN LB statement RB if1
    (78) while_st -> . WHILE LP expression RP DO LB main1 RB
    (79) from_st -> . FROM ID list1 EQ expression UNTIL expression DO LB main1 RB
    (80) return_st -> . RETURN LP expression RP
    (59) var -> . ID list1
    (60) var -> . ID DOT ID

    RB              reduce using rule 105 (empty -> .)
    ID              shift and go to state 85
    READ            shift and go to state 86
    WRITE           shift and go to state 87
    IF              shift and go to state 88
    WHILE           shift and go to state 89
    FROM            shift and go to state 90
    RETURN          shift and go to state 91

    main1                          shift and go to state 220
    statement                      shift and go to state 74
    empty                          shift and go to state 75
    assignment                     shift and go to state 76
    void_call                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    if_st                          shift and go to state 80
    while_st                       shift and go to state 81
    from_st                        shift and go to state 82
    return_st                      shift and go to state 83
    var                            shift and go to state 84

state 219

    (79) from_st -> FROM ID list1 EQ expression UNTIL expression DO LB main1 . RB

    RB              shift and go to state 221


state 220

    (76) if1 -> ELSE LB main1 . RB

    RB              shift and go to state 222


state 221

    (79) from_st -> FROM ID list1 EQ expression UNTIL expression DO LB main1 RB .

    ID              reduce using rule 79 (from_st -> FROM ID list1 EQ expression UNTIL expression DO LB main1 RB .)
    READ            reduce using rule 79 (from_st -> FROM ID list1 EQ expression UNTIL expression DO LB main1 RB .)
    WRITE           reduce using rule 79 (from_st -> FROM ID list1 EQ expression UNTIL expression DO LB main1 RB .)
    IF              reduce using rule 79 (from_st -> FROM ID list1 EQ expression UNTIL expression DO LB main1 RB .)
    WHILE           reduce using rule 79 (from_st -> FROM ID list1 EQ expression UNTIL expression DO LB main1 RB .)
    FROM            reduce using rule 79 (from_st -> FROM ID list1 EQ expression UNTIL expression DO LB main1 RB .)
    RETURN          reduce using rule 79 (from_st -> FROM ID list1 EQ expression UNTIL expression DO LB main1 RB .)
    RB              reduce using rule 79 (from_st -> FROM ID list1 EQ expression UNTIL expression DO LB main1 RB .)


state 222

    (76) if1 -> ELSE LB main1 RB .

    ID              reduce using rule 76 (if1 -> ELSE LB main1 RB .)
    READ            reduce using rule 76 (if1 -> ELSE LB main1 RB .)
    WRITE           reduce using rule 76 (if1 -> ELSE LB main1 RB .)
    IF              reduce using rule 76 (if1 -> ELSE LB main1 RB .)
    WHILE           reduce using rule 76 (if1 -> ELSE LB main1 RB .)
    FROM            reduce using rule 76 (if1 -> ELSE LB main1 RB .)
    RETURN          reduce using rule 76 (if1 -> ELSE LB main1 RB .)
    RB              reduce using rule 76 (if1 -> ELSE LB main1 RB .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for CLASS in state 14 resolved as shift
WARNING: shift/reduce conflict for VOID in state 33 resolved as shift
WARNING: shift/reduce conflict for INT in state 33 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 33 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 33 resolved as shift
WARNING: shift/reduce conflict for ID in state 56 resolved as shift
WARNING: shift/reduce conflict for ID in state 99 resolved as shift
WARNING: shift/reduce conflict for READ in state 99 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 99 resolved as shift
WARNING: shift/reduce conflict for IF in state 99 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 99 resolved as shift
WARNING: shift/reduce conflict for FROM in state 99 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 99 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 203 resolved as shift
